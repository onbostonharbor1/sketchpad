<script>
/**
 * Draw a nautilus-style object on a 2D canvas.
 * 
 * @param {CanvasRenderingContext2D} ctx - 2D context to draw into.
 * @param {Object} o - Options to control all aspects.
 * @param {number}  o.cx=0                 - Center x.
 * @param {number}  o.cy=0                 - Center y.
 * @param {number}  o.rotation=0           - Global rotation (radians).
 * @param {number}  o.turns=3.5            - Spiral length in turns.
 * @param {number}  o.points=1200          - Total sample points along the spiral.
 * @param {number}  o.startRadius=6        - Spiral scale factor “a” (pixels).
 * @param {number}  o.tightness=0.18       - Spiral tightness “b” for r = a·e^(bθ).
 * @param {boolean} o.drawSpiral=true      - Stroke the main spiral.
 * @param {number}  o.spiralWidth=3        - Line width for main spiral.
 * @param {string}  o.spiralColor='#111'   - Stroke style for main spiral.
 * @param {boolean} o.fillShell=false      - If true, fills with a thick stroke look.
 * @param {number}  o.shellThickness=26    - Effective thickness if fillShell = true.
 * @param {string}  o.shellColor='#f4efe6' - Fill color when fillShell = true.
 * @param {boolean} o.ribs=true            - Draw curve-stitch ribs between points.
 * @param {number}  o.interval=45          - Connect point i → i+interval (integer >= 1).
 * @param {number}  o.ribEvery=2           - Draw rib at every Nth base point.
 * @param {number}  o.ribAlpha=0.25        - Opacity for rib strokes (0..1).
 * @param {number}  o.ribWidth=1           - Line width for ribs.
 * @param {string}  o.ribColor='#2c3e50'   - Stroke color for ribs (alpha applied).
 * @param {boolean} o.chambers=true        - Mark chamber boundaries.
 * @param {number}  o.chamberGrowth=1.25   - Each chamber grows radius by this factor (k).
 * @param {number}  o.maxChambers=18       - Max number of chamber marks to draw.
 * @param {number}  o.chamberWidth=1.5     - Line width for chamber marks.
 * @param {string}  o.chamberColor='#555'  - Stroke color for chamber marks.
 * @returns {{points: Array<{x:number,y:number,theta:number,r:number}>}}
 *          The sampled spiral points (useful if you want to add your own effects).
 */
function drawNautilus(ctx, o = {}) {
  // defaults
  const {
    cx = 0, cy = 0, rotation = 0,
    turns = 3.5, points = 1200, startRadius = 6, tightness = 0.18,
    drawSpiral = true, spiralWidth = 3, spiralColor = '#111',
    fillShell = false, shellThickness = 26, shellColor = '#f4efe6',
    ribs = true, interval = 45, ribEvery = 2, ribAlpha = 0.25, ribWidth = 1, ribColor = '#2c3e50',
    chambers = true, chamberGrowth = 1.25, maxChambers = 18, chamberWidth = 1.5, chamberColor = '#555'
  } = o;

  // --- generate spiral points r = a * e^(bθ)
  const theta0 = 0;
  const theta1 = turns * Math.PI * 2;
  const N = Math.max(2, Math.floor(points));
  const pts = new Array(N);

  for (let i = 0; i < N; i++) {
    const t = i / (N - 1);
    const theta = theta0 + t * (theta1 - theta0);
    const r = startRadius * Math.exp(tightness * theta);
    const a = theta + rotation;
    const x = cx + r * Math.cos(a);
    const y = cy + r * Math.sin(a);
    pts[i] = { x, y, theta, r };
  }

  // helper to draw a polyline
  function strokePolyline(points, width, color) {
    if (points.length < 2) return;
    ctx.save();
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.stroke();
    ctx.restore();
  }

  // --- fill shell look (fake thickness by stroking multiple offsets)
  if (fillShell) {
    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = shellColor;
    // simulate thickness by wide stroke of the polyline
    ctx.lineWidth = shellThickness;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
    ctx.restore();
  }

  // --- main spiral
  if (drawSpiral) {
    strokePolyline(pts, spiralWidth, spiralColor);
  }

  // --- curve-stitch ribs (i -> i + interval)
  if (ribs && interval >= 1) {
    ctx.save();
    ctx.lineWidth = ribWidth;
    // apply alpha by rgba() to keep compatibility with globalAlpha users
    const c = ctx.strokeStyle = ribColor;
    const rgba = toRGBA(c, ribAlpha);
    ctx.strokeStyle = rgba;

    // draw sparse ribs to avoid overdraw
    for (let i = 0; i + interval < N; i += Math.max(1, ribEvery)) {
      const a = pts[i];
      const b = pts[i + interval];

      // draw a shallow quadratic curve bending outward a bit (looks more “nautilus”)
      // control point at weighted normal between a and b:
      const mx = (a.x + b.x) * 0.5;
      const my = (a.y + b.y) * 0.5;

      // approximate outward normal based on local direction at point i
      const dir = directionAt(pts, i);
      const nx = -dir.y, ny = dir.x;
      const bulge = 0.35 * Math.hypot(b.x - a.x, b.y - a.y);
      const cx1 = mx + nx * bulge;
      const cy1 = my + ny * bulge;

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.quadraticCurveTo(cx1, cy1, b.x, b.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  // --- chamber marks: radii grow by constant factor k along the same spiral
  if (chambers) {
    // For r(θ+Δθ) = k·r(θ) on r = a·e^(bθ), Δθ = ln(k)/b
    const k = chamberGrowth;
    const b = tightness;
    const dTheta = Math.log(k) / (b || 1e-6);
    ctx.save();
    ctx.lineWidth = chamberWidth;
    ctx.strokeStyle = chamberColor;

    for (let n = 0; n < maxChambers; n++) {
      const θ = theta0 + n * dTheta;
      if (θ > theta1) break;

      // sample a short arc centered near this θ to create a “septum” curve
      const span = Math.min(0.9 * dTheta, Math.PI / 3); // keep it local
      const steps = 24;
      const local = [];
      for (let j = 0; j <= steps; j++) {
        const t = (j / steps - 0.5) * span + θ;
        const r = startRadius * Math.exp(b * t);
        const a = t + rotation;
        local.push({
          x: cx + r * Math.cos(a),
          y: cy + r * Math.sin(a)
        });
      }
      strokePolyline(local, chamberWidth, chamberColor);
    }
    ctx.restore();
  }

  return { points: pts };

  // ---- helpers
  function directionAt(arr, i) {
    const i0 = Math.max(0, i - 1);
    const i1 = Math.min(arr.length - 1, i + 1);
    const dx = arr[i1].x - arr[i0].x;
    const dy = arr[i1].y - arr[i0].y;
    const len = Math.hypot(dx, dy) || 1;
    return { x: dx / len, y: dy / len };
  }

  function toRGBA(color, alpha) {
    // Accepts named colors/hex; uses canvas to parse reliably.
    const c = document.createElement('canvas');
    c.width = c.height = 1;
    const _ctx = c.getContext('2d');
    _ctx.fillStyle = color;
    const parsed = _ctx.fillStyle; // normalized like 'rgb(r, g, b)'
    const m = parsed.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if (!m) return color;
    const [r, g, b] = [m[1], m[2], m[3]];
    return `rgba(${r},${g},${b},${alpha})`;
  }
}

// Minimal usage
</script>
<canvas id="c" width="2000" height="2000"></canvas>
<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.translate(canvas.width * 0.48, canvas.height * 0.55); // put center somewhere pleasing

  drawNautilus(ctx, {
    cx: 50,
    cy: 150,
    rotation: -Math.PI * 0.25,
    turns: 4.0,
    points: 1600,
    startRadius: 4,
//    tightness: 0.22,           // higher = tighter spiral
    tightness: .3,
    fillShell: true,
    shellThickness: 34,
    shellColor: '#f2efe8',
    drawSpiral: true,
    spiralWidth: 2,
    spiralColor: '#222',
    ribs: true,
    interval: 50,              // spacing between stitched points
    ribEvery: 2,
    ribAlpha: 0.22,
    ribWidth: 1,
    ribColor: '#2c3e50',
    chambers: true,
    chamberGrowth: 1.23,       // growth per chamber
    maxChambers: 22,
    chamberWidth: 1.25,
    chamberColor: '#666'
  });
</script>

