<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nautilus — Curve Stitching</title>
  <style>
    :root{ --bg:#0b1020; --fg:#e6f3ff; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:var(--fg);background:var(--bg)}
    .app{display:grid;grid-template-columns:1fr 320px;height:100vh;gap:16px;padding:16px;box-sizing:border-box}
    .card{background:rgba(255,255,255,0.03);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,0.6);}
    canvas{width:100%;height:100%;display:block;border-radius:10px}
    .controls{display:flex;flex-direction:column;gap:12px}
    label{font-size:13px;opacity:0.9}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px;align-items:center}
    .btn{background:#16a34a;color:white;border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
    .muted{opacity:0.7;font-size:13px}
    footer{font-size:12px;opacity:0.7;margin-top:8px}
  </style>
</head>
<body>
  <div class="app">
    <div class="card" style="display:flex;flex-direction:column;">
      <canvas id="c"></canvas>
    </div>
    <div class="card controls">
      <h3 style="margin:0 0 4px 0">Nautilus — Curve Stitching</h3>
      <div class="muted">A parametric / logarithmic spiral with chord-stitching produces shell-like ridges.</div>

      <div>
        <label>Points: <span id="pointsVal">600</span></label>
        <input id="points" type="range" min="64" max="3000" value="600">
      </div>
      <div>
        <label>Turns (θ max / 2π): <span id="turnsVal">6</span></label>
        <input id="turns" type="range" min="1" max="20" value="6">
      </div>
      <div>
        <label>Spiral tightness (b): <span id="bVal">0.20</span></label>
        <input id="b" type="range" min="0.05" max="0.8" step="0.01" value="0.2">
      </div>

      <div>
        <label>Chord skip (connect i → i + skip): <span id="skipVal">10</span></label>
        <input id="skip" type="range" min="1" max="200" value="10">
      </div>
      <div>
        <label>Stroke opacity: <span id="alphaVal">0.12</span></label>
        <input id="alpha" type="range" min="0.01" max="0.5" step="0.01" value="0.12">
      </div>
      <div class="row">
        <button id="redraw" class="btn">Redraw</button>
        <button id="export" class="btn" style="background:#2563eb">Export PNG</button>
      </div>
      <footer>Tip: increase points and lower opacity for smoother shells. Try different skip values to change ridges.</footer>
    </div>
  </div>

  <script>
    // Nautilus — curve stitching in a single HTML file
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // Controls
    const pointsSlider = document.getElementById('points');
    const pointsVal = document.getElementById('pointsVal');
    const turnsSlider = document.getElementById('turns');
    const turnsVal = document.getElementById('turnsVal');
    const bSlider = document.getElementById('b');
    const bVal = document.getElementById('bVal');
    const skipSlider = document.getElementById('skip');
    const skipVal = document.getElementById('skipVal');
    const alphaSlider = document.getElementById('alpha');
    const alphaVal = document.getElementById('alphaVal');
    const redrawBtn = document.getElementById('redraw');
    const exportBtn = document.getElementById('export');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function lerp(a,b,t){return a + (b-a)*t}
    // Logarithmic spiral in polar: r = a * e^(b * theta)

    function generateSpiralPoints({points=600, turns=6, a=4, b=0.2, centerX, centerY, scale=1}){
      const pts = new Array(points);
      const thetaMax = turns * Math.PI * 2;
      // We'll space theta so points are roughly evenly spaced along angle; radial spacing emerges from r(
      for(let i=0;i<points;i++){
        const t = i / (points - 1);
        const theta = t * thetaMax;
        const r = a * Math.exp(b * theta);
        const x = centerX + r * Math.cos(theta) * scale;
        const y = centerY + r * Math.sin(theta) * scale;
        pts[i] = {x,y,theta,r};
      }
      return pts;
    }

    function draw(){
      resize();
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // parameters from UI
      const points = Number(pointsSlider.value);
      const turns = Number(turnsSlider.value);
      const b = Number(bSlider.value);
      const skip = Number(skipSlider.value);
      const alpha = Number(alphaSlider.value);

      pointsVal.textContent = points;
      turnsVal.textContent = turns;
      bVal.textContent = b.toFixed(2);
      skipVal.textContent = skip;
      alphaVal.textContent = alpha.toFixed(2);

      // Clear
      ctx.clearRect(0,0,W,H);

      // background radial gradient
      const grad = ctx.createLinearGradient(0,0,W,H);
      grad.addColorStop(0,'#071025');
      grad.addColorStop(1,'#07111d');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,W,H);

      // center and scaling
      const cx = W * 0.36; // offset left for aperture
      const cy = H * 0.5;

      // pick scale so spiral fits in canvas
      // estimate r_max = a * exp(b * thetaMax)
      const a = 2.8; // base radius -- tweak for aesthetics
      const thetaMax = turns * Math.PI * 2;
      const rMax = a * Math.exp(b * thetaMax);

      // set scale so rMax * scale ~ min(W,H)*0.6
      const scale = Math.min(W,H) * 0.55 / rMax;
      const pts = generateSpiralPoints({points, turns, a, b, centerX:cx, centerY:cy, scale});

      // for nicer colors create gradient palette along points
      function colorForIndex(i){
        const t = i / points;
        // color moves from warm to pale cream like shell
        const r = Math.round(lerp(220,255, Math.pow(t,0.6)));
        const g = Math.round(lerp(160,245, Math.pow(t,0.9)));
        const bl = Math.round(lerp(120,220, t));
        return `rgba(${r},${g},${bl},${alpha})`;
      }

      ctx.lineWidth = 1.0;
      ctx.lineCap = 'round';

      // Curve stitching: draw chords connecting i -> (i + skip) % points
      // We'll draw multiple layers with varying skip to get ridges
      const layerSkips = [skip, Math.max(1, Math.floor(skip*0.6)), Math.max(1, Math.floor(skip*1.5))];
      for(let layer=0; layer<layerSkips.length; layer++){
        const s = layerSkips[layer];
        for(let i=0;i<points;i++){
          const j = (i + s) % points;
          const p = pts[i];
          const q = pts[j];
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(q.x, q.y);

          // subtle stroke style influenced by i
          ctx.strokeStyle = colorForIndex(i);
          ctx.stroke();
        }
      }

      // Draw outline spiral (accent)
      ctx.beginPath();
      for(let i=0;i<points;i++){
        const p = pts[i];
        if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1.4;
      ctx.stroke();

      // highlight aperture (the shell opening center)
      ctx.beginPath();
      ctx.arc(cx, cy, Math.max(6, Math.min(40, Math.log(points) * 2)), 0, Math.PI*2);
      ctx.fillStyle = 'rgba(8,10,15,0.9)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    // initial draw and interactions
    function scheduleDraw(){
      window.requestAnimationFrame(draw);
    }

    window.addEventListener('resize', scheduleDraw);
    redrawBtn.addEventListener('click', scheduleDraw);
    pointsSlider.addEventListener('input', scheduleDraw);
    turnsSlider.addEventListener('input', scheduleDraw);
    bSlider.addEventListener('input', scheduleDraw);
    skipSlider.addEventListener('input', scheduleDraw);
    alphaSlider.addEventListener('input', scheduleDraw);

    exportBtn.addEventListener('click', ()=>{
      const link = document.createElement('a');
      link.download = 'nautilus.png';
      // for export we need an offscreen canvas at full pixel size
      const out = document.createElement('canvas');
      const dpr = window.devicePixelRatio || 1;
      out.width = canvas.width; out.height = canvas.height;
      const outCtx = out.getContext('2d');
      outCtx.setTransform(dpr,0,0,dpr,0,0);
      // draw onto outCtx by calling drawToContext

      // Temporarily create copy of generate/draw but using outCtx
      (function(){
        const W = canvas.clientWidth; const H = canvas.clientHeight;
        outCtx.clearRect(0,0,W,H);
        const grad = outCtx.createLinearGradient(0,0,W,H);
        grad.addColorStop(0,'#071025');
        grad.addColorStop(1,'#07111d');
        outCtx.fillStyle = grad;
        outCtx.fillRect(0,0,W,H);

        const points = Number(pointsSlider.value);
        const turns = Number(turnsSlider.value);
        const b = Number(bSlider.value);
        const skip = Number(skipSlider.value);
        const alpha = Number(alphaSlider.value);

        const cx = W * 0.36; const cy = H * 0.5;
        const a = 2.8;
        const thetaMax = turns * Math.PI * 2;
        const rMax = a * Math.exp(b * thetaMax);
        const scale = Math.min(W,H) * 0.55 / rMax;
        const pts = generateSpiralPoints({points, turns, a, b, centerX:cx, centerY:cy, scale});

        function colorForIndex(i){
          const t = i / points;
          const r = Math.round(lerp(220,255, Math.pow(t,0.6)));
          const g = Math.round(lerp(160,245, Math.pow(t,0.9)));
          const bl = Math.round(lerp(120,220, t));
          return `rgba(${r},${g},${bl},${alpha})`;
        }

        outCtx.lineWidth = 1.0; outCtx.lineCap='round';
        const layerSkips = [skip, Math.max(1, Math.floor(skip*0.6)), Math.max(1, Math.floor(skip*1.5))];
        for(let layer=0; layer<layerSkips.length; layer++){
          const s = layerSkips[layer];
          for(let i=0;i<points;i++){
            const j = (i + s) % points;
            const p = pts[i]; const q = pts[j];
            outCtx.beginPath(); outCtx.moveTo(p.x,p.y); outCtx.lineTo(q.x,q.y);
            outCtx.strokeStyle = colorForIndex(i); outCtx.stroke();
          }
        }
        outCtx.beginPath();
        for(let i=0;i<points;i++){ const p=pts[i]; if(i===0) outCtx.moveTo(p.x,p.y); else outCtx.lineTo(p.x,p.y); }
        outCtx.strokeStyle = 'rgba(255,255,255,0.08)'; outCtx.lineWidth=1.6; outCtx.stroke();

        outCtx.beginPath(); outCtx.arc(cx,cy,Math.max(6, Math.min(40, Math.log(points) * 2)),0,Math.PI*2);
        outCtx.fillStyle='rgba(8,10,15,0.9)'; outCtx.fill(); outCtx.strokeStyle='rgba(255,255,255,0.06)'; outCtx.lineWidth=1.2; outCtx.stroke();
      })();

      link.href = out.toDataURL('image/png');
      link.click();
    });


    // initial
    scheduleDraw();
  </script>
</body>
</html>
