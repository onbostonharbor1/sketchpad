<!--
    Here you go, Barryâ€”a full, standalone HTML + JavaScript scaffold for your Curve-Stitch Visual Debugger. This version includes:
â€¢ ðŸ§µ Point generation (circle, line, grid)
â€¢ ðŸ§  Custom connection rule editor
â€¢ ðŸ”¢ Point index labels
â€¢ ðŸ”— Connection lines with directional highlighting
â€¢ ðŸ–±ï¸ Hover inspection for individual points
â€¢ âœ… Debug mode toggle

---
ðŸ§¾ Full HTML + JS: Curve-Stitch Visual Debugger -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Curve-Stitch Visual Debugger</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { border: 1px solid #333; display: block; margin-bottom: 20px; }
    label { display: block; margin: 5px 0; }
    textarea { width: 100%; height: 80px; }
    #tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
<h1>ðŸ§µ Curve-Stitch Visual Debugger</h1>
<canvas id="canvas" width="600" height="600"></canvas>
<div id="tooltip"></div>
<label>Point Generator:
  <select id="pointGen">
    <option value="circle">Circle</option>
    <option value="line">Line</option>
    <option value="grid">Grid</option>
  </select>
</label>
<label>Point Count: <input type="range" id="pointCount" min="10" max="200" value="100"></label>
<label>Connection Rule (JavaScript expression):</label>
<textarea id="ruleInput">return (i + 50) % points.length;</textarea>
<label><input type="checkbox" id="debugToggle" checked> Show Debug Info</label>
<button id="renderBtn">ðŸ”„ Render</button>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
let points = [];
function generatePoints(type, count) {
  const w = canvas.width, h = canvas.height;
  const result = [];
  switch (type) {
    case 'circle':
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        result.push({
          x: w / 2 + 200 * Math.cos(angle),
          y: h / 2 + 200 * Math.sin(angle)
        });
      }
      break;
    case 'line':
      for (let i = 0; i < count; i++) {
        result.push({
          x: 100 + (400 * i / (count - 1)),
          y: h / 2
        });
      }
      break;
    case 'grid':
      const cols = Math.ceil(Math.sqrt(count));
      const rows = Math.ceil(count / cols);
      for (let i = 0; i < count; i++) {
        const x = (i % cols) * (w / cols) + w / (2 * cols);
        const y = Math.floor(i / cols) * (h / rows) + h / (2 * rows);
        result.push({ x, y });
      }
      break;
  }
  return result;
}
function drawPointLabels(points) {
  ctx.fillStyle = 'red';
  points.forEach((pt, i) => {
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'black';
    ctx.font = '10px sans-serif';
    ctx.fillText(i, pt.x + 5, pt.y - 5);
  });
}
function renderStitch() {
  const type = document.getElementById('pointGen').value;
  const count = parseInt(document.getElementById('pointCount').value);
  const ruleCode = document.getElementById('ruleInput').value;
  const debug = document.getElementById('debugToggle').checked;
  points = generatePoints(type, count);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let ruleFn;
  try {
    ruleFn = new Function('i', 'points', ruleCode);
  } catch (err) {
    alert("Invalid rule: " + err.message);
    return;
  }
  for (let i = 0; i < points.length; i++) {
    let j;
    try {
      j = ruleFn(i, points);
    } catch (err) {
      continue;
    }
    if (typeof j === 'number' && j >= 0 && j < points.length) {
      ctx.strokeStyle = `hsl(${(i / points.length) * 360}, 100%, 50%)`;
      ctx.beginPath();
      ctx.moveTo(points[i].x, points[i].y);
      ctx.lineTo(points[j].x, points[j].y);
      ctx.stroke();
    }
  }
  if (debug) drawPointLabels(points);
}
document.getElementById('renderBtn').addEventListener('click', renderStitch);
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const hovered = points.findIndex(pt => {
    const dx = pt.x - mx;
    const dy = pt.y - my;
    return Math.sqrt(dx*dx + dy*dy) < 5;
  });
  if (hovered !== -1) {
    const ruleCode = document.getElementById('ruleInput').value;
    let ruleFn;
    try {
      ruleFn = new Function('i', 'points', ruleCode);
      const j = ruleFn(hovered, points);
      tooltip.style.left = `${e.clientX + 10}px`;
      tooltip.style.top = `${e.clientY + 10}px`;
      tooltip.innerText = `Point ${hovered} â†’ ${j}`;
      tooltip.style.display = 'block';
    } catch {
      tooltip.style.display = 'none';
    }
  } else {
    tooltip.style.display = 'none';
  }
});
renderStitch();
</script>
</body>
</html>
