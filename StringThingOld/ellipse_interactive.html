<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ellipse Points — Interactive</title>
<style>
  :root { --bg:#0b0f14; --fg:#e9eef3; --muted:#9db0c3; --accent:#7cc4ff; --line:#86ffa8; --dot:#ffd36e; }
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg);}
  header{padding:16px 20px;border-bottom:1px solid #1b2733;display:flex;align-items:center;gap:10px;}
  h1{font-size:18px;margin:0;font-weight:600;letter-spacing:.3px;}
  main{display:grid;grid-template-columns:340px 1fr; gap:16px; padding:16px;}
  .panel{background:#0f1620;border:1px solid #1b2733;border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.25);}
  .grid{display:grid;grid-template-columns:1fr; gap:12px;}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}
  input[type="range"]{width:100%;}
  .row{display:grid;grid-template-columns:1fr auto; gap:8px; align-items:center;}
  .val{font-size:12px;color:var(--accent);min-width:52px;text-align:right;}
  .radios{display:flex; gap:12px; font-size:13px; color:var(--muted);}
  canvas{width:100%; height:100%; background:#0a0f16; border:1px solid #1b2733; border-radius:14px;}
  .canvas-wrap{position:relative; height:72vh; min-height:420px;}
  .note{font-size:12px;color:var(--muted); margin-top:6px;}
  .footer{font-size:11px;color:#7c8b9b; margin-top:8px;}
  .btn{background:#142132;border:1px solid #213041;color:var(--fg);padding:8px 10px;border-radius:10px;cursor:pointer;}
  .btn:hover{background:#1a2a3d;}
  .stack{display:flex; gap:8px; flex-wrap:wrap;}
</style>
</head>
<body>
  <header>
    <h1>Ellipse Points — Interactive</h1>
    <div class="footer">Drag sliders or type values; the canvas updates live.</div>
  </header>
  <main>
    <section class="panel">
      <div class="grid">
        <div class="row">
          <div>
            <label for="width">Ellipse width (major axis)</label>
            <input id="width" type="range" min="20" max="800" step="1" value="360">
          </div>
          <div class="val"><input id="widthNum" type="number" min="20" max="2000" step="1" value="360" style="width:70px;background:transparent;border:1px solid #273445;color:inherit;border-radius:8px;padding:4px 6px;"></div>
        </div>
        <div class="row">
          <div>
            <label for="height">Ellipse height (minor axis)</label>
            <input id="height" type="range" min="20" max="600" step="1" value="220">
          </div>
          <div class="val"><input id="heightNum" type="number" min="20" max="2000" step="1" value="220" style="width:70px;background:transparent;border:1px solid #273445;color:inherit;border-radius:8px;padding:4px 6px;"></div>
        </div>
        <div class="row">
          <div>
            <label for="rotation">Rotation (degrees)</label>
            <input id="rotation" type="range" min="-180" max="180" step="1" value="30">
          </div>
          <div class="val"><input id="rotationNum" type="number" min="-360" max="360" step="1" value="30" style="width:70px;background:transparent;border:1px solid #273445;color:inherit;border-radius:8px;padding:4px 6px;"></div>
        </div>
        <div class="row">
          <div>
            <label for="npts">Number of points</label>
            <input id="npts" type="range" min="3" max="1000" step="1" value="120">
          </div>
          <div class="val"><input id="nptsNum" type="number" min="3" max="5000" step="1" value="120" style="width:70px;background:transparent;border:1px solid #273445;color:inherit;border-radius:8px;padding:4px 6px;"></div>
        </div>
        <div>
          <label>Spacing</label>
          <div class="radios">
            <label><input type="radio" name="spacing" value="angle" checked> equal-angle</label>
            <label><input type="radio" name="spacing" value="arclen"> equal-arc-length (approx)</label>
          </div>
          <div class="note">Arc-length spacing uses a lookup table to invert cumulative arc length; increase "resolution" for precision.</div>
        </div>
        <div class="row">
          <div>
            <label for="res">Arc-length resolution (steps)</label>
            <input id="res" type="range" min="200" max="8000" step="50" value="2000">
          </div>
          <div class="val"><input id="resNum" type="number" min="100" max="20000" step="50" value="2000" style="width:80px;background:transparent;border:1px solid #273445;color:inherit;border-radius:8px;padding:4px 6px;"></div>
        </div>
        <div class="stack">
          <button id="downloadJson" class="btn">Download points (JSON)</button>
          <button id="snapPng" class="btn">Download canvas (PNG)</button>
          <button id="reset" class="btn">Reset view</button>
        </div>
      </div>
    </section>
    <section class="panel canvas-wrap">
      <canvas id="c"></canvas>
    </section>
  </main>

<script>
// ===== Geometry core =====
function ellipsePointsAngle(width, height, cx, cy, rotation, numPoints){
  const points = [];
  const a = width/2, b = height/2;
  const cosR = Math.cos(rotation), sinR = Math.sin(rotation);
  for(let i=0;i<numPoints;i++){
    const theta = 2*Math.PI*i/numPoints;
    const x0 = a*Math.cos(theta);
    const y0 = b*Math.sin(theta);
    const xr = x0*cosR - y0*sinR;
    const yr = x0*sinR + y0*cosR;
    points.push({x: cx + xr, y: cy + yr});
  }
  return points;
}

function ellipsePointsArcLength(width, height, cx, cy, rotation, numPoints, steps=2000){
  const a = width/2, b = height/2;
  const cosR = Math.cos(rotation), sinR = Math.sin(rotation);
  const lookup = new Array(steps+1);
  let totalLength = 0;
  let prevX = a, prevY = 0;
  lookup[0] = {theta:0, len:0};
  for(let i=1;i<=steps;i++){
    const th = 2*Math.PI*i/steps;
    const x = a*Math.cos(th), y = b*Math.sin(th);
    const dx = x-prevX, dy = y-prevY;
    totalLength += Math.hypot(dx,dy);
    lookup[i] = {theta: th, len: totalLength};
    prevX = x; prevY = y;
  }
  function thetaForLen(target){
    let lo=0, hi=steps;
    while(lo<hi){
      const mid=(lo+hi>>1);
      if(lookup[mid].len < target) lo = mid+1;
      else hi = mid;
    }
    return lookup[lo].theta;
  }
  const pts=[];
  for(let i=0;i<numPoints;i++){
    const s = (i/numPoints)*totalLength;
    const th = thetaForLen(s);
    const x0 = a*Math.cos(th), y0 = b*Math.sin(th);
    const xr = x0*cosR - y0*sinR;
    const yr = x0*sinR + y0*cosR;
    pts.push({x: cx + xr, y: cy + yr});
  }
  return pts;
}

// ===== Canvas + UI =====
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let view = { panX: 0, panY: 0, zoom: 1 };

function resizeCanvas(){
  const rect = canvas.parentElement.getBoundingClientRect();
  const ratio = devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * ratio);
  canvas.height = Math.floor(rect.height * ratio);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(ratio,0,0,ratio,0,0);
  draw();
}
window.addEventListener('resize', resizeCanvas);

// UI bindings
const $ = (id)=>document.getElementById(id);
const widthRange = $('width'), widthNum = $('widthNum');
const heightRange = $('height'), heightNum = $('heightNum');
const rotationRange = $('rotation'), rotationNum = $('rotationNum');
const nptsRange = $('npts'), nptsNum = $('nptsNum');
const resRange = $('res'), resNum = $('resNum');
const spacingRadios = Array.from(document.querySelectorAll('input[name=spacing]'));
const btnDownload = $('downloadJson');
const btnSnap = $('snapPng');
const btnReset = $('reset');

function bindPair(range, num, on){
  function syncFromRange(){ num.value = range.value; on(); }
  function syncFromNum(){ range.value = num.value; on(); }
  range.addEventListener('input', syncFromRange);
  num.addEventListener('change', syncFromNum);
}
spacingRadios.forEach(r => r.addEventListener('change', draw));
bindPair(widthRange, widthNum, draw);
bindPair(heightRange, heightNum, draw);
bindPair(rotationRange, rotationNum, draw);
bindPair(nptsRange, nptsNum, draw);
bindPair(resRange, resNum, draw);

btnReset.addEventListener('click', ()=>{ view = {panX:0, panY:0, zoom:1}; draw(); });

// Pan/zoom
let dragging=false, lastX=0, lastY=0;
canvas.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', ()=> dragging=false);
window.addEventListener('mousemove', (e)=>{
  if(!dragging) return;
  view.panX += (e.clientX-lastX);
  view.panY += (e.clientY-lastY);
  lastX=e.clientX; lastY=e.clientY;
  draw();
});
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const sign = Math.sign(e.deltaY);
  const factor = sign>0 ? 0.9 : 1.1;
  view.zoom *= factor;
  draw();
}, {passive:false});

function getParams(){
  const width = parseFloat(widthRange.value);
  const height = parseFloat(heightRange.value);
  const rotation = parseFloat(rotationRange.value) * Math.PI/180;
  const npts = Math.max(3, parseInt(nptsRange.value,10)|0);
  const steps = Math.max(100, parseInt(resRange.value,10)|0);
  const spacing = spacingRadios.find(r=>r.checked).value;
  const cx = canvas.width/(devicePixelRatio||1)/2;
  const cy = canvas.height/(devicePixelRatio||1)/2;
  return {width,height,rotation,npts,steps,spacing,cx,cy};
}

function generatePoints(p){
  if(p.spacing==='angle'){
    return ellipsePointsAngle(p.width, p.height, p.cx, p.cy, p.rotation, p.npts);
  } else {
    return ellipsePointsArcLength(p.width, p.height, p.cx, p.cy, p.rotation, p.npts, p.steps);
  }
}

function draw(){
  const p = getParams();
  ctx.save();
  // clear
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // view
  const ratio = devicePixelRatio || 1;
  ctx.setTransform(ratio*view.zoom,0,0,ratio*view.zoom, ratio*view.panX, ratio*view.panY);

  // background grid
  drawGrid();

  // ellipse points
  const pts = generatePoints(p);

  // polyline
  ctx.beginPath();
  for(let i=0;i<pts.length;i++){
    const q = pts[i];
    if(i===0) ctx.moveTo(q.x, q.y); else ctx.lineTo(q.x, q.y);
  }
  ctx.closePath();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line');
  ctx.stroke();

  // dots
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dot');
  for(const q of pts){
    ctx.beginPath();
    ctx.arc(q.x, q.y, 2.2, 0, Math.PI*2);
    ctx.fill();
  }

  // center + axes
  ctx.strokeStyle = '#33516f';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(p.cx-9999, p.cy);
  ctx.lineTo(p.cx+9999, p.cy);
  ctx.moveTo(p.cx, p.cy-9999);
  ctx.lineTo(p.cx, p.cy+9999);
  ctx.stroke();

  ctx.restore();

  // make points available for download
  canvas._points = pts;
}

function drawGrid(){
  const W = canvas.width/(devicePixelRatio||1);
  const H = canvas.height/(devicePixelRatio||1);
  const step = 50;
  ctx.save();
  ctx.beginPath();
  for(let x=0;x<=W;x+=step){
    ctx.moveTo(x,0); ctx.lineTo(x,H);
  }
  for(let y=0;y<=H;y+=step){
    ctx.moveTo(0,y); ctx.lineTo(W,y);
  }
  ctx.strokeStyle = '#122131';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

// Downloads
btnDownload.addEventListener('click', ()=>{
  const pts = canvas._points || [];
  const blob = new Blob([JSON.stringify(pts,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ellipse_points.json';
  a.click();
  URL.revokeObjectURL(url);
});

btnSnap.addEventListener('click', ()=>{
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ellipse_canvas.png';
  a.click();
});

// init
resizeCanvas();
draw();
</script>
</body>
</html>
