<html>
  <body>
    <script>
/**
 * Draws a curve stitching visualization of the mice problem.
 * @param {CanvasRenderingContext2D} ctx The 2D rendering context of the canvas.
 * @param {number} nMice The number of mice (and polygon vertices). Must be >= 3.
 * @param {number} sideLength The side length of the initial regular polygon.
 * @param {number} iterations The number of lines to draw for the stitching effect.
 * @param {number} tStep The time increment for each step of the simulation.
 * @param {number} scale A scaling factor for the drawing.
 */
function drawMicePursuit(ctx, nMice, sideLength, iterations, tStep, scale) {
  if (nMice < 3) {
    console.error("Number of mice must be 3 or more.");
    return;
  }

  // Set up canvas origin at the center for easier drawing
  const centerX = ctx.canvas.width / 2;
  const centerY = ctx.canvas.height / 2;
  ctx.translate(centerX, centerY);

  // Clear the canvas
  ctx.clearRect(-centerX, -centerY, ctx.canvas.width, ctx.canvas.height);

  // Initialize mouse positions
  const initialPositions = [];
  const radius = (sideLength / 2) / Math.sin(Math.PI / nMice);
  for (let i = 0; i < nMice; i++) {
      const angle = (2 * Math.PI * i / nMice) +
	    (nMice % 2 === 0 ? Math.PI / nMice : 0);
      initialPositions.push({
	  x: radius * Math.cos(angle) * scale,
	  y: radius * Math.sin(angle) * scale
      });
  }

  let currentPositions = [...initialPositions];
  ctx.lineWidth = 1;
//  ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)'; // Faded color for the stitching
  ctx.strokeStyle = 'blue';
  for (let i = 0; i < iterations; i++) {
    // Draw lines between current mouse positions
    for (let j = 0; j < nMice; j++) {
      ctx.beginPath();
      ctx.moveTo(currentPositions[j].x, currentPositions[j].y);
      const nextMouse = (j + 1) % nMice;
      ctx.lineTo(currentPositions[nextMouse].x, currentPositions[nextMouse].y);
      ctx.stroke();
    }

    // Calculate the next positions based on the pursuit paths
    const nextPositions = [];
    for (let j = 0; j < nMice; j++) {
      const targetMouse = (j + 1) % nMice;
      const dx = currentPositions[targetMouse].x - currentPositions[j].x;
      const dy = currentPositions[targetMouse].y - currentPositions[j].y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Mouse speed is constant (e.g., 1 unit/time)
      const vx = (dx / distance);
      const vy = (dy / distance);

      // Move toward the next mouse by a time step
      const newX = currentPositions[j].x + vx * tStep * scale;
      const newY = currentPositions[j].y + vy * tStep * scale;
      nextPositions.push({ x: newX, y: newY });
    }
    currentPositions = nextPositions;
  }

  // Draw the final positions (the center of the polygon)
//  ctx.fillStyle = 'red';
//  ctx.beginPath();
//  ctx.arc(0, 0, 5 * scale, 0, 2 * Math.PI);
//  ctx.fill();

  // Draw the starting dots
//  ctx.fillStyle = 'black';
//  initialPositions.forEach(pos => {
//    ctx.beginPath();
//    ctx.arc(pos.x, pos.y, 3 * scale, 0, 2 * Math.PI);
//    ctx.fill();
//  });
}
</script>
</head>
<body>
  <canvas id="miceCanvas" width="500" height="500"></canvas>
  <script>
    const canvas = document.getElementById('miceCanvas');
    const ctx = canvas.getContext('2d');
    let numMice = 5;
    let sideLength = 250;
    let numSteps = 95;
    let tStep    = 4;
    let scale    = 1;
    drawMicePursuit(ctx, numMice, sideLength, numSteps, tStep, scale);
//    drawMicePursuit(ctx, 4, 200, 500, 0.05, 1);
  </script>
</body>
</html>

