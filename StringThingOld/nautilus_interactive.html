<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Interactive Nautilus Curve</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Arial; background:#111; color:#eee; }
    .container { display:flex; gap:20px; padding:20px; align-items:flex-start; }
    canvas { background: #0b0b0b; border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.6); }
    .controls { width:320px; }
    .control { margin-bottom:12px; }
    label { display:block; font-size:13px; margin-bottom:4px; color:#ddd; }
    input[type=range] { width:100%; }
    .row { display:flex; gap:8px; align-items:center; }
    button { padding:8px 12px; background:#1e90ff; border:0; color:white; border-radius:6px; cursor:pointer; }
    .muted { color:#bbb; font-size:13px; }
    footer { padding:12px; color:#888; font-size:13px; text-align:center; }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="c" width="900" height="900"></canvas>
    <div class="controls">
      <div class="control"><label>Turns: <span id="turnsVal">5</span></label><input id="turns" type="range" min="1" max="30" step="0.5" value="5"></div>
      <div class="control"><label>Tightness (b): <span id="bVal">0.20</span></label><input id="b" type="range" min="0.03" max="0.6" step="0.01" value="0.20"></div>
      <div class="control"><label>Scale (a): <span id="aVal">4.0</span></label><input id="a" type="range" min="0.5" max="20" step="0.1" value="4.0"></div>
      <div class="control"><label>Point density: <span id="ptsVal">2000</span></label><input id="pts" type="range" min="200" max="8000" step="50" value="2000"></div>
      <div class="control"><label>Stroke width: <span id="lineVal">1.4</span></label><input id="line" type="range" min="0.3" max="6" step="0.1" value="1.4"></div>
      <div class="control"><label>Hue shift: <span id="hueVal">20</span></label><input id="hue" type="range" min="0" max="360" step="1" value="20"></div>
      <div class="control"><label>Chamber effect (thickness): <span id="thickVal">6</span></label><input id="thick" type="range" min="0" max="24" step="1" value="6"></div>
      <div class="control row">
        <button id="animateBtn">Toggle Rotate</button>
        <button id="downloadBtn">Download PNG</button>
      </div>
      <p class="muted">Tip: increase Tightness and Turns for a dense nautilus. Lower b for looser (more open) spiral.</p>
      <p class="muted">Curve equation: r(θ) = a * e^(b θ)</p>
    </div>
  </div>
  <footer>Interactive Nautilus — adjustable parameters. Built with HTML5 canvas.</footer>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2;
  // controls
  const inputs = ['turns','b','a','pts','line','hue','thick'].reduce((o,id)=>{ o[id]=document.getElementById(id); return o; },{});
  const displays = { turns: 'turnsVal', b: 'bVal', a: 'aVal', pts: 'ptsVal', line: 'lineVal', hue: 'hueVal', thick: 'thickVal' };
  Object.keys(displays).forEach(k=>{ document.getElementById(displays[k]).innerText = inputs[k].value; });
  Object.values(inputs).forEach(inp=> inp.addEventListener('input', ()=> { updateDisplays(); render(); }));
  function updateDisplays(){
    Object.keys(displays).forEach(k=>{ document.getElementById(displays[k]).innerText = inputs[k].value; });
  }

  let rotating = false;
  let angleOffset = 0;
  document.getElementById('animateBtn').addEventListener('click', ()=>{ rotating = !rotating; document.getElementById('animateBtn').innerText = rotating? 'Stop Rotate' : 'Toggle Rotate'; });
  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'nautilus.png';
    link.click();
  });

  // spiral param: r = a * exp(b * theta)
  function buildSpiral(a,b,turns,pts,thetaOffset=0) {
    const ptsArr = [];
    const thetaMax = turns * 2 * Math.PI;
    for(let i=0;i<pts;i++){
      const t = i / (pts-1);
      const theta = thetaOffset + t * thetaMax;
      const r = a * Math.exp(b * theta);
      const x = cx + r * Math.cos(theta);
      const y = cy + r * Math.sin(theta);
      ptsArr.push({x,y,theta,r});
    }
    return ptsArr;
  }

  function hsl(h,s,l){ return 'hsl('+ (h|0) +', '+ Math.round(s*100) +'%,'+ Math.round(l*100)+'%)'; }

  function render(now){
    if(rotating) angleOffset += 0.003 * (1 + parseFloat(inputs.b.value)); // slow rotation influenced by b
    // clear
    ctx.clearRect(0,0,w,h);
    // fetch params
    const turns = parseFloat(inputs.turns.value);
    const b = parseFloat(inputs.b.value);
    const a = parseFloat(inputs.a.value);
    const pts = parseInt(inputs.pts.value,10);
    const lw = parseFloat(inputs.line.value);
    const hue = parseInt(inputs.hue.value,10);
    const thick = parseInt(inputs.thick.value,10);

    // build spiral points
    const spiral = buildSpiral(a, b, turns, pts, angleOffset);

    // compute bounding radius for gradient scaling
    let maxR = 0; for(const p of spiral) if(p.r>maxR) maxR=p.r;

    // draw smooth polyline with color varying by theta and a chamber offset for thickness
    ctx.lineJoin = 'round'; ctx.lineCap = 'round';
    // draw multiple stroked paths to imitate chambers (offsets)
    const passes = Math.max(1, Math.floor(1 + thick/3));
    for(let pass=0; pass<passes; pass++){
      ctx.beginPath();
      for(let i=0;i<spiral.length;i++){
        const p = spiral[i];
        // small radial offset per pass to create layered chambers
        const offset = (pass / Math.max(1,passes-1) - 0.5) * thick * 0.7;
        const offx = offset * Math.cos(p.theta + Math.PI/2);
        const offy = offset * Math.sin(p.theta + Math.PI/2);
        const x = p.x + offx, y = p.y + offy;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      // color depends on theta (along shell)
      const gradHue = (hue + pass*12) % 360;
      ctx.strokeStyle = hsl(gradHue, 0.78, 0.55);
      ctx.lineWidth = lw * (1 - pass*0.08);
      ctx.globalAlpha = 1.0 - pass*0.06;
      ctx.stroke();
    }

    // optional: draw faint guide dots at some points
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    const step = Math.max(8, Math.floor(pts / 80));
    for(let i=0;i<spiral.length;i+=step){
      const p = spiral[i];
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0.8, Math.min(3, 3 * (1 - i/spiral.length))), 0, Math.PI*2);
      ctx.fill();
    }

    // subtle vignette
    const g = ctx.createRadialGradient(cx, cy, Math.max(10, maxR*0.1), cx, cy, Math.max(10, maxR*1.05));
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // request next frame if rotating
    if(rotating) requestAnimationFrame(render);
  }

  // initial render
  render();
})();
</script>
</body>
</html>
