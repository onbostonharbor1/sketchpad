<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Figure 250</title>
<script type="text/javascript">
// class: Point
//	  StringThing
//        radiate object
// Main Functions:
//    drawCircularParabola(StringThing)
//    drawCycloid(StringThing)
//    drawInEllipse(StringThing)
//    drawInCircle(StringThing)
//    DRAWINVERSESTAR(STRINGTHING)
//    drawMysticRose(StringThing)
//    drawParab(StringThing,parabola)
//    drawParabs(StringThing,parabolaArray)
//    drawParametric(funcX,funcY, pts)
//         drawPolar(angle,rad, pts)
//         range(low,high,numPoints
//    drawPursuitCurve...
//    drawRadiate(radiateObject);
//    DRAWREGULARPOLYGON(StringThing)
//    drawRegularPolygonCorner(StringThing)
//         getEllipseNodes(s
//    pointsOnParabola(StringThing,parab)
//    Print Routines
//       printCircNum(pt[,offset])
//       printNodes(nodes,numNodes)       // OBSOLETE
//       printANode(pt,num)
//       printText(text)
//       printTitle(text)
//    ptsOnLine(numSteps,start,end);
//    scaleNodes(nodes,thing)
//   _scaleNodes(nodes,xScale,yScale,midpoint)
//    setPt(point)
//    shortenArms(thing)
//    showBaseline(thing)           // NO LONGER USED
//    showColors(color)
//    showNodes(StringThing)        // NO LONGER USED
//    testCircle(pt,color,width)
//             Used in debugging as less typing than drawCircle
//
//    REPLACE BUILTIN FUNCTIONS: moveTo, lineTo, beginPath, closePath, stroke)

// STRUCTURAL FUNCTIONS
//    Debugger.log()
//    canvasApp()
//    drawScreen()
//    eventwindowLoaded(): invokes canvasApp()

// CONSTANTS AND GLOBALS
const blue      = "blue";
const CLOSE     = true;
const DONT_DRAW = true;

const START_END   = -1;
const FULL        = 0;
const TAPER       = 1;
const START_TAPER = 2;
const END_TAPER   = 3;

let gl = {
    dot:     false,
    final:   false,
    newLine: 10,
    pts:     new Array,
    ctr:     0
}

// ------------ SETUP ----------------
window.addEventListener("load", eventWindowLoaded, false);	

var Debugger = function () { };

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// BUGS: bendY not debugged
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

function eventWindowLoaded () {
      canvasApp();
}
///////////////////////////////////////////////
 Debugger.log = function (message) {
      try {
        console.log(message);
      } catch (exception) {
	  return;
      }
  }

  // Called after window is loaded event
function canvasApp () {
      var theCanvas = document.getElementById("StringThing");
      var context   = theCanvas.getContext("2d"); 
    let ctx       = context;
      Debugger.log("Drawing Canvas");

      // THIS IS WHERE THE DRAWING OCCURS
      function drawScreen() {


// ------------ BEGIN ----------------

	  context.clearRect(0,0,theCanvas.width,theCanvas.height);
//        background("darkblue");
//  	  background("white",true);
//  	  background("black");
//  	  background("lightpink");
//	  background(calculateTintAndShade
//                           (colourNameToHex("blue"),.9).tint.hex);

// ------------ TESTS ----------------
//OK	  test1();    // right  
	  test2();    // regular shapes
//	  test3();    // circle
//	  test4();    // parabs
//   	  test5();    // pts from array
//	  test6();    // drawRadiate
//	  test7();    // arc points (circular arms)
//	  test8();    // draw with points on parabola
//	  test9();    // draw equal chords
//	  test10();   // draw mystic rose
//	  test11();   // two linked circles
//	  test12();   // circular parabola
//        test13();   // color shading test
//	  test14();   // cycloid
//	  test15();   // create ellipse nodes
//	  test16();   // crosshair
//	  test17();   // full ellipse with rotation
//	  test18();   // pursuit
//	  test19();   // twisted arms
//	  test20();   // spirals
//	  test21();   // drawParab
//	  test22();   // return coordinates of a line
//	  test23();   // rotate a line
//	  test24();   // draw parametric
//	  test26();   // Number in a circle
//	  test27();   // draw radial parametric
//	  test28a();  // sine wave
//	  test28();   // another sine wave, showing nods
//	  test29();   // drawing chords
//	  test30();   // pure spiral
//	  test31();   // pure spiral, take 2
//	  test32();   // pure spiral, take 3
//	  test33();   // fermat spiral
//        test34();   // log spiral
//	  test35();   // draw euler spiral
//	  test36();   // spiral of theodorus
//        test37();   // drawing chords
//	  test38();   // drawInCircle, redux
//	  test39();   // playing with circles
//	  test40();   // Shading
//	  test41();   // arc drawing, with radius
//	  test42();   // arc, with curvature
//          test43();   // strophoid


	  
// ------------ FIGURES ----------------

//	  figure23();
//	  figure72();
//	  figure60(); 
//	  figure81();
//	  figure82(); 
//	  figure83();  
//	  figure84();
//	  figure85();
//	  figure98();  
//        figure99();  
//	  figure151();
//	  figure158();
//	  figure173();
//	  figure177();
//	  figure201();
//	  squareSine();
//	  figure204();
//	  figure205();
//	  figure206a();
//	  figure209();
//	  figure209a();
//	  figure209test();
//	  figure237();
//	  figure242();
//	  figure245();
//	  figure246();
//	  figure250();
//	  figure255();
//	  figure255d();
//	  figure255k();
//	  figure282();

//	  console.log(showColors("green"));
//	  inchesToPixels();
	  //        ellipseCircumference

      } // End DRAWSCREEN

    //////////////////////////////////////////////////////////

    


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// CLASSES
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
    
class StringThing {
      constructor(s) {
  	  let canvas         = document.querySelector("#StringThing");
	  
                                       // bends at midpoint
	  if (!("bendY"        in s))  s.bendY        = 0;       
                                       // CircularParabola: do clockwise and
                                       // counterclockwise at same time
	  if (!("both"         in s))  s.both         = false;	  
	  if (!("color"        in s))  s.color        = "black";	  
	                               // pointsOnParabola: at some point, 
                                       // want to stop drawing from the 
                                       // parabola to the arm
	  if (!("cutoff"       in s))  s.cutoff       = s.numSteps/2;	  
                                       // InverseStar: shrinks the arms. 
                                       // Differs from shorten in that
                                       // this starts from the end of the arm
	  if (!("factor"       in s))  s.factor       = 0;	  
	  if (!("lineWidth"    in s))  s.lineWidth    = 1;	  
                                       // midpoints are added between nodes 
	  if (!("mid"          in s))  s.mid          = false;	  
	                               // actual midpoint of drawn object
	  if (!("midpoint"     in s))  s.midpoint = new Point(200,200);
	                               // sets the number of points. Code 
	                               // wants the number to be one greater
	  if (!("numCycloids"  in s))  s.numCycloids  = 1;	  
	  if (!("numNodes"     in s))  s.numNodes     = 4;	  
	  if (!("numSteps"     in s))  s.numSteps     = 20;	  
	  if (!("radius"       in s))  s.radius       = 200;	  
	  if (!("rotate"       in s))  s.rotate       = 0;
	                               // the percent to shorten
	  if (!("shorten"      in s))  s.shorten      = 0;	  
	  // stitcher:   start and end positions for going through
	  //             steps
	  // drawChords: where in the list of steps to begin and
	  //             end drawing
	  if (!("startSkip"    in s))  s.startSkip    = 0;	  
	  if (!("endSkip"      in s))  s.endSkip      = 0;	  
                                       // pattern skipping, like when drawing 
                                       // around a circle. For example, skip 4
                                       // means go from node[0] to node[4] or
                                       // from node[20] to node[24]
	  if (!("skip"         in s))  s.skip         = 10;
	  //                          -1 (START_END    )=end a starting point 
	  //                           0 (FULL)        =full circle 
	  //                           1 (TAPER)       =start and end taper 
	  //                           2 (START_TAPER)
	  //                           1 (END_TAPER)   
	  if (!("withinCirc"   in s))  s.withinCirc    = FULL;
	  
	  if (!("start"        in s))  s.start        = new Point(150, 50);
	  if (!("start"        in s))  s.endSkip      = 0;	  
	                               // Only do the first N steps in stitcher
	  if (!("trunc"        in s))  s.trunc        = false;	  
	  if (!("yIncrement"   in s))  s.yIncrement   = 1;
                                       // scale is a factor, not percent
	  if (!("xScale"       in s))  s.xScale       = 1;	  
	  if (!("yScale"       in s))  s.yScale       = 1;
	  if (!("ellipse"      in s))  s.ellipse = { a: s.radius, b: s.radius };

			
	  //////////////////////////////////////////////////////
	  this.arm1         = null;
	  this.arm2         = null;
	  this.type;
	  this._bendSteps   = false;          // only used internally
	  this.bendY        = s.bendY;
	  this.both   = s.both;
	  this.color        = s.color;
	  this.cutoff       = s.cutoff;
	  this.ellipse      = s.ellipse;
	  this.endSkip      = s.endSkip;
	  this.factor       = s.factor;
	  this.lineWidth    = s.lineWidth;
	  this.mid          = s.mid;
	  this.midpoint     = s.midpoint;
	  this.numCycloids  = s.numCycloids+1;
          this.numNodes     = s.numNodes;
	  this.numSteps     = s.numSteps;
	  this.radius       = s.radius;
	  this.rotate       = s.rotate;
	  this.shorten      = s.shorten;
	  this.skip         = s.skip;
	  this.start        = s.start;
	  this.startSkip    = s.startSkip;
	  this.trunc        = s.trunc;
	  this.withinCirc   = s.withinCirc;
	  this.yIncrement   = s.yIncrement;
	  this.xScale       = s.xScale;
	  this.yScale       = s.yScale;
//	  if (!("printNodes"   in s))  s.printNodes   = false;	  
//	  if (!("showNodes"    in s))  s.showNodes    = false;
//	  if (!("taper"        in s))  s.taper         = 0;
//	  this.printNodes   = s.printNodes;
//	  this.showNodes    = s.showNodes;
//	  this.taper        = s.taper;
	  
      }
    set newColor(col)   { this.color    = col; }
    set newNodes(nodes) { this.numNodes = nodes; }
    set newSteps(steps) { this.numSteps = steps; }
    set thisType(type)  { this.type     = type; }
    set newArm2(arm)    { this.arm2     = arm; }
  }


class Point {
    constructor (x,y) {
	if (typeof(x)=="number") {
	    this.x = x;
	    this.y = y;
	} else {
	    this.x = gl.pts[x].x;
	    this.y = gl.pts[x].y;
	}
    }
}

//class Radiate {
//    constructor (r) {
//	if (!("color"     in r))  r.color     = "blue";
//	if (!("bend"      in r))  r.bend      = 0;
//	if (!("lineWidth" in r))  r.lineWidth = 1;
//	if (!("numSteps"  in r))  r.numSteps  = 20;
//        
//	this.color     = r.color;
//	this.bend      = r.bend;
//	this.lineWidth = r.lineWidth;
//	this.nodes     = r.nodes;
//	this.numSteps  = r.numSteps;
//	this.start     = r.start;
//    }
//}  // end Radiate

/////////////////////////////////////////////////////////////////  
/////////////////////////////////////////////////////////////////  
// FUNCTIONS GO BELOW HERE
/////////////////////////////////////////////////////////////////  
/////////////////////////////////////////////////////////////////  



/////////////////////////////////////////////////////////////////
// drawCycloid
/////////////////////////////////////////////////////////////////
      function drawCycloid(thing) {
	  nodes = createNodes(thing);
          beginPath();
 	  context.strokeStyle = thing.color;
	  context.lineWidth   = thing.lineWidth;
	  context.lineCap     = 'round';
	  for (i=0; i< thing.numNodes -1; i++) {
	      j = thing.numCycloids*i % thing.numNodes;
	      moveTo(nodes[i].x,nodes[i].y);
	      lineTo(nodes[j].x,nodes[j].y);
	  }
	  moveTo(nodes[0].x,nodes[0].y);
	  for (i=1; i < thing.numNodes; i++) {
	      lineTo(nodes[i].x,nodes[i].y);
	  }
	  stroke();
	  closePath();
      } // end drawCycloid


/////////////////////////////////////////////////////////////////
// drawInCircle
/////////////////////////////////////////////////////////////////
    function drawInCircle(thing){
	thing.ellipse = { a: thing.radius, b: thing.radius } ;
	drawInEllipse(thing);
   }

    function drawInEllipse(thing) {

	function drawStart(nodes, skip, color, start, dist=4) {
	    // inc gives a slight small setting to the distance
	    // between the start and end positions of the line
	    let inc = dist;
	    let i = 0;
	    let j;
	    let numLines = skip - 4;
	    for (; i < numLines; i++) {
		// inc being equal to zero is really a flag
		// saying "just find the end of the taper
		// without drawing a line
		if (dist != DONT_DRAW) {
		    j = (i+start) % nodes.length;
		    let k = (j+inc) % nodes.length;
		    drawLine(nodes[j],nodes[k],color);
		    inc++;
		}
	    }

	    return j+1;
	}
	
	function drawWithin(nodes, skip, color, start, end) {
	    let i = 0;
	    let k;
	    let numLines = end - skip;
	    for (;i < numLines; i++){
		let j = (start + i) % nodes.length;
		k = (j+skip) % nodes.length;
		drawLine(nodes[j],nodes[k],color);
	    }
	    return i+start;
	}

	function drawEnd(nodes, skip, color, start, length, dist=4) {
            let j;
	    for (let i=start, j=0; i < length; i+=2) {
		skip--;
		j = i % nodes.length;
		k = (i+skip+1) % nodes.length;
		drawLine(nodes[j],nodes[k],color);
	    }
	}

	const DISTANCE = 4;
	let color  = thing.color;
	let skip   = thing.skip;
	let nodes  = createEllipseNodes(thing);
	let start  = 0;
	let end    = nodes.length;
	             // length = total of nodes to be done
	             // it will be greater than nodes.length
	             // if startSkip or endSkip is negative
	let length = end;

// COMPLETE CIRCLE
	if (thing.withinCirc == FULL) {
	    drawLinesAllAround(nodes,skip,color);
	    drawNodes(nodes,color);
	    return;
	}

// if adding an arm at the beginning of end	
// must be withinCirc = START_END

	if (Array.isArray(thing.arm1) || Array.isArray(thing.arm2))	
	    thing.withinCirc = START_END;

	if (Array.isArray(thing.arm1) ||
	    Array.isArray(thing.arm2))   {
	    if (Array.isArray(thing.arm1)) {
		// Im assuming that end point of grafted
		// line shares a point on the circle
		nodes.shift();
		nodes = thing.arm1.concat(nodes);
	    }
	    if (Array.isArray(thing.arm2)) {
		nodes = nodes.concat(thing.arm2);
	    }
// BROKEN
	    drawWithin(nodes,skip, color, start, length);
//	    drawWithin(nodes,skip,color,nodes.length-skip);
	    return;
	}
  
	if (thing.startSkip > 0) {
	    start   = thing.startSkip;
	    length -= thing.startSkip;
	} else if (thing.startSkip < 0) {
	    // if startSkip is negative, starting position is at
	    // that number of points from the end of "nodes"
	    start   = nodes.length + thing.startSkip;    // startSkip is negative
	    length -= thing.startSkip;
	}
	if (thing.endSkip > 0) {
	    end     = nodes.length - thing.endSkip;
	    length -= thing.endSkip;
	} else if (thing.endSkip < 0) {
            end     = -thing.endSkip;           // endSkip is negative
	    length -= thing.endSkip;
	}
	// DRAW OUTLINE
	let ctr = 0;
	for (let i=start; i < start+length-1; i++) {
	    j = i % nodes.length;
	    k = (i+1) % nodes.length;
	    drawLine(nodes[j],nodes[k],color);
	    ctr++;
	    if (ctr > nodes.length) break;	    
	    }
	    
	// START_END WITHIN, NO TAPER
	if (thing.withinCirc == START_END) {
	    drawWithin(nodes,skip, color, start, length);
	    return;
	}

	// START_TAPER
	if (thing.withinCirc == START_TAPER) {
	    start=drawStart(nodes,skip,color,start,DISTANCE);
	    drawWithin(nodes,skip,color,start,length-start+thing.startSkip);
	    return;
	}

	// END_TAPER
	if (thing.withinCirc == END_TAPER) {
	    end = length-skip+DISTANCE;
	    start = drawWithin(nodes,skip,color,start,end);
	    drawEnd(nodes,skip,color,start,length-thing.startSkip);
	    return;
	}
	// TAPER
	start = drawStart(nodes,skip,color,start,DISTANCE);
	end = length-skip+DISTANCE-start+thing.startSkip;
	start = drawWithin(nodes,skip,color,start,end);
	drawEnd(nodes,skip,color,start,length);

    }
    
/////////////////////////////////////////////////////////////////
// drawMysticRose
/////////////////////////////////////////////////////////////////
      function drawMysticRose(thing){
	  nodes = createNodes(thing);
 	  context.strokeStyle = thing.color;
	  beginPath();
          for (i=0; i < nodes.length; i++){
              for (j=0; j < nodes.length -1; j++) {
		  if (j != i) {
		      moveTo(nodes[i].x,nodes[i].y);
		      lineTo(nodes[j].x,nodes[j].y);
		  }
	      }
	  }
	  stroke();
          closePath();
      } // end drawMysticRose
      


/////////////////////////////////////////////////////////////////
// drawParab
/////////////////////////////////////////////////////////////////
      function drawParab(thing, Parab){
	  if (Parab.length == 3)
	      Parab.splice(1,0, Parab[1]);
	  parab = numbersToPoints(Parab);
	  thing.arm1 = ptsOnLine(thing.numSteps, parab[0], parab[1]);
	  thing.arm2 = ptsOnLine(thing.numSteps, parab[2], parab[3]);
	  stitcher(thing);
      } // end drawParab

/////////////////////////////////////////////////////////////////
// drawParabs
/////////////////////////////////////////////////////////////////
// MOVED
      function drawParabs(thing, Parabs){
	  for (i=0; i < Parabs.length; i++){
	      parab = Parabs[i];
	      if (parab.length == 3)
		  parab.splice(1,0, parab[1]);
//	      foo = Parabs[i];
//	      parabs = numbersToPoints(Parabs[i]);
//	      thing.arm1 = ptsOnLine(thing.numSteps, parabs[i][0], parabs[i][1]);
//	      thing.arm2 = ptsOnLine(thing.numSteps, parabs[i][2], parabs[i][3],thing.yIncrement);
	      thing.arm1 = ptsOnLine(thing.numSteps, parab[0], parab[1]);
	      thing.arm2 = ptsOnLine(thing.numSteps, parab[2], parab[3],thing.yIncrement);
	      stitcher(thing);

	  }
      } // end drawParabs

/////////////////////////////////////////////////////////////////
// PARAMETRICS
//    drawPolar    
//    drawParametric
//    range
/////////////////////////////////////////////////////////////////
	  function drawPolar(angle, rad, pts) {
	      let funcX = function(t) {
//		  return .5*rad(t) * Math.cos(angle(t));
		  return rad(t) * Math.cos(angle(t));
	      }
	      let funcY = function(t) {
//		  return .5*rad(t) * Math.sin(angle(t));
		  return rad(t) * Math.sin(angle(t));
	      }
	      drawParametric(funcX,funcY,pts);
	  }

                      ////////////////////
                      // range
                      ////////////////////
	  function range (low, high, numPoints) {
	      let delta = high - low;
	      let step  = delta/numPoints;
	      const arr = [];
	      for (let i=0;i<(numPoints+1); i++) {
		  arr.push(low += step);
	      }
	      return arr;
	  }
	  

                      ////////////////////
                      // drawParametric
                      ////////////////////
	  function drawParametric(funcX, funcY, pts) {
	      let scale = 60;
	      let midX = 200;
	      let midY = 200;
	      function MidX(coord,midX) {
		  return scale*(coord)+midX;
	      }
	      function MidY(coord,midX) {
		  return scale*(coord)+midY;
	      }
	      let x1, y1, x2, y2;
	      for (let i=0; i<pts.length-1; i++) {
		  x1 = MidX(funcX(pts[i]),   midX);
		  y1 = MidY(funcY(pts[i]),   midY);
		  x2 = MidX(funcX(pts[i+1]), midX);
		  y2 = MidY(funcY(pts[i+1]), midY);
		  drawLine(new Point(x1,y1), new Point(x2,y2),"blue",.5);
	      }
	  }



//////////////////////////////////////////////////////////////////
// drawPursuitCurve
//////////////////////////////////////////////////////////////////
      function drawPursuitCurve(rabbitStart, foxStart, rabbitSpeed,
				foxSpeed, timeStep, maxIterations) {
	  let rabbitPos  = rabbitStart;
	  let foxPos     = foxStart;
	  let rabbitPath = [rabbitPos];
	  let foxPath    = [foxPos]; // Store the fox's path
	  for (let i = 0; i < maxIterations; i++) {
	      // Move the rabbit
	      rabbitPos = { x: rabbitPos.x + rabbitSpeed * timeStep,
			    y: rabbitPos.y };
	      rabbitPath.push(rabbitPos);
	      // Calculate direction from fox to rabbit
	      let direction = { x: rabbitPos.x - foxPos.x,
				y: rabbitPos.y - foxPos.y };
	      let magnitude = Math.sqrt(direction.x * direction.x
					+ direction.y * direction.y);
	      let unitDirection = { x: direction.x / magnitude,
				    y: direction.y / magnitude };
	      // Move the fox
	      foxPos = { x: foxPos.x + unitDirection.x * foxSpeed * timeStep,
			 y: foxPos.y + unitDirection.y * foxSpeed * timeStep };
	      foxPath.push(foxPos);
	      if (magnitude < 180) break; // Stop if the fox is close enough
	  }
	  for (i=0; i < rabbitPath.length; i++) {
              start = new Point(foxPath[i].x,   foxPath[i].y);
              end   = new Point(rabbitPath[i].x,rabbitPath[i].y);
	      drawLine(start,end,"blue");
	  }
      }
// end drawPursuitCurve


/////////////////////////////////////////////////////////////////
// drawRadiate
//      While uses members with same name as StringThing,
//      they are not part of StringThing class
/////////////////////////////////////////////////////////////////
      function drawRadiate(r){
	  let color           = context.strokeStyle;
	  let lineWidth       = context.lineWidth;
	  context.strokeStyle = r.color;
	  context.lineWidth   = r.lineWidth;
	  for (let i=0; i < r.nodes.length-1; i++) {
	      moveTo(r.start.x,    r.start.y);
	      lineTo(r.nodes[i].x, r.nodes[i].y);
	  }
	  stroke();
	  closePath();
	  context.strokeStyle = color;
	  context.lineWidth = lineWidth;
      } // end drawRadiate


/////////////////////////////////////////////////////////////////
// drawTwoLinkedCircles
/////////////////////////////////////////////////////////////////
      function drawTwoLinkedCircles(c2){
	  c2.type = "TwoLinkedCircles";
 	  context.strokeStyle = c2.color;
	  beginPath();
	  drawCircle(c2.mid1,c2.radius,c2.color);
	  drawCircle(c2.mid2,c2.radius,c2.color);
	  p = (2*Math.PI)/c2.numPoints;
	  for (i=0; i < 2*Math.PI; i+=p) {
              h = i+p*c2.numSteps;
	      moveTo(c2.mid1.x+c2.radius*Math.sin(i),
			     c2.mid1.y-c2.radius*Math.cos(i));
	      lineTo(c2.mid2.x+c2.radius*Math.sin(h),
			     c2.mid2.y-c2.radius*Math.cos(h));
	  }
	  stroke();
	  closePath();
      }  // end drawTwoLinkedCircles

/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
// SPIRALS
//    drawEulerSpiral
//    drawFermatSpiral
//    drawLogarithmicSpiral
//    drawPureSpiral
//    drawPureSpiralA
//    drawPureSpiralB
//    drawSpiral (probably misnamed)
//    drawTheodorusSpiral
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////
// drawEulerSpiral
//////////////////////////////////////////////////////////////////
// Example usage:
// const myCanvas = document.getElementById("myCanvas");
// drawEulerSpiral(myCanvas, 10, 10000, 50);     

   function drawEulerSpiral(thing,totalLength, numSegments, scaleFactor) {
	let x = 0;
	let y = 0;
	let t = 0;
	const dt = totalLength / numSegments;
	
	context.beginPath();
	context.lineWidth = 1;
	context.moveTo(x+thing.midpoint.x, y+thing.midpoint.y); // Start at the origin
	
	for (let i = 0; i < numSegments; i++) {
	    // Approximate the Fresnel integral steps
	    const dx = Math.cos(t * t / 2) * dt;
	    const dy = Math.sin(t * t / 2) * dt;
	    
	    x += dx * scaleFactor;
	    y += dy * scaleFactor;
	    t += dt;
	    
	    context.lineTo(x+thing.midpoint.x, y+thing.midpoint.y);
	}
	context.stroke();
    }

//////////////////////////////////////////////////////////////////
// drawFermatSpiral
//////////////////////////////////////////////////////////////////
   function drawFermatSpiral(thing, scaleFactor, numTurns, gap) {
	context.strokeStyle = thing.color;
	context.lineWidth   = thing.lineWidth;
	const a = scaleFactor; // The 'a' constant in the Fermat spiral equation
	const maxTheta = numTurns * 2 * Math.PI; // Total angle to draw

	context.beginPath();
	let firstPoint = true;
	for (let theta = 0; theta <= maxTheta; theta += 0.01) { // Increment theta in small steps
	    const r = a * Math.sqrt(theta); // Calculate radius

	    const x = thing.midpoint.x + r * Math.cos(theta)*gap;
	    const y = thing.midpoint.y + r * Math.sin(theta)*gap;

	    if (firstPoint) {
		context.moveTo(x, y);
		firstPoint = false;
	    } else {
		context.lineTo(x, y);
	    }
	}
	context.stroke();
}

//////////////////////////////////////////////////////////////////
//  drawLogarithmicSpiral
//////////////////////////////////////////////////////////////////
//    r is the radius from the origin.
//    a is a scaling factor that determines the initial radius when theta is 0.
//    b controls the tightness or "pitch" of the spiral.
//                A larger b results in a faster-expanding spiral.
//    theta is the angle in radians, representing the rotation around the origin. 
//    a, b: The a and b parameters from the logarithmic spiral equation.
//    startAngle, endAngle: The range of angles (in radians) 
//               over which to draw the spiral.
//    step: The increment for theta in each iteration, determining 
//               the smoothness of the drawn spiral. 
//

//    By adjusting the a, b, startAngle, endAngle, and step parameters,
//    you can control the size, tightness, and extent of the generated
//    logarithmic spiral. 

 function drawLogarithmicSpiral(thing, a, b, startAngle, endAngle, step) {
     context.strokeStyle = thing.color;
     context.lineWidth   = thing.lineWidth;
     context.beginPath();
     let firstPoint = true;

     for (let theta = startAngle; theta <= endAngle; theta += step) {
         const r = a * Math.exp(b * theta);
         const x = thing.midpoint.x + r * Math.cos(theta);
         const y = thing.midpoint.y + r * Math.sin(theta);

         if (firstPoint) {
             context.moveTo(x, y);
             firstPoint = false;
         } else {
             context.lineTo(x, y);
         }
     }
     context.stroke();
 }    

//////////////////////////////////////////////////////////////////
// drawPureSpiral
//////////////////////////////////////////////////////////////////
    function drawPureSpiral(thing,angle,spread,maxAngle) {
	context.strokeStyle = thing.color;
	context.lineWidth   = thing.lineWidth;
//	let counter = 0;
	for (let angle = 0; angle <= maxAngle; angle += 0.01) { // Increment angle in small steps
            const radius = thing.radius + spread * angle;
            const x = thing.midpoint.x + radius * Math.cos(angle);
            const y = thing.midpoint.y + radius * Math.sin(angle);

           if (angle === 0) {
		context.moveTo(x, y); // Start the path
            } else {
		context.lineTo(x, y); // Draw line segments
            }
//	    if ((counter % 100) == 0) printCircNum(new Point(x,y));
//	    counter++;
	}
	context.stroke();
    }

//////////////////////////////////////////////////////////////////
// drawPureSpiralA
//////////////////////////////////////////////////////////////////
    function drawPureSpiralA(thing,gap,numRotations) {
	context.strokeStyle = thing.color;
	context.lineWidth   = thing.lineWidth;
        context.moveTo(thing.midpoint.x, thing.midpoint.y);
    
//        var gap = 1.8;                // increase this for spacing between spiral lines        
        var STEPS_PER_ROTATION = 60; // increasing this makes the curve smoother
    
        var increment = 2*Math.PI/STEPS_PER_ROTATION;		
        var theta = increment;
        while( theta < numRotations*Math.PI) {
           var newX = thing.midpoint.x + theta * Math.cos(theta) * gap; 
           var newY = thing.midpoint.y + theta * Math.sin(theta) * gap; 
           context.lineTo(newX, newY);
           theta = theta + increment;
        }
	context.fillStyle = "green";
	context.fill();
        context.stroke(); // draw the spiral
    }
        
//////////////////////////////////////////////////////////////////
// drawPureSpiralB
//////////////////////////////////////////////////////////////////
     function drawPureSpiralB(thing,ptsToDraw) {
	 context.strokeStyle = thing.color;
	 context.lineWidth   = thing.lineWidth;
	 context.fillStyle   = "green";
	 angleInc = toRadians(10);                // increase revolutions

	 outer_rad = 150;                            // size of spiral
	 for (let i=1; i<ptsToDraw; ++i) {
             ratio = i/ptsToDraw;
	     angle = i*angleInc;
	     spiralRad = ratio*outer_rad;
	     x = thing.midpoint.x + Math.cos(angle) * spiralRad;
	     y = thing.midpoint.y + Math.sin(angle) * spiralRad;
	     context.beginPath();
	     context.arc(x,y,1,0,2*Math.PI,false);
	     context.fill();
	 }
     }

//////////////////////////////////////////////////////////////////
// drawSpiral
//////////////////////////////////////////////////////////////////
      function drawSpiral(s) {
	  let j;
	  let points = [];
	  if (!Array.isArray(s.interval)) {
	      interval = Array(s.container.length).fill(s.interval);
	  } else {
	      interval = s.interval;
	  }
	  intervalStep = [];
	  for (i=0; i<interval.length; i++){
	      intervalStep[i] = interval[i]/s.numSteps;
	  }
	  // draw outer shape
	  for (i=0;i<s.container.length;i++){
	      if (i==(s.container.length-1)) j=0;
	      else j=i+1;
              drawLine(s.container[i],s.container[j],s.color);
	      points[i] = [];
	      points[i].push(s.container[i]);
	  }
	  // NOW WE REALLY BEGIN
	  for (let i=0; i < s.numSteps; i++) {
	      for (let j=0;j<s.container.length;j++) {
		  if (j==(s.container.length-1))
		      k=0;
		  else
		      k=j+1;
		  deltaX    = points[k][i].x - points[j][i].x;
		  deltaY    = points[k][i].y - points[j][i].y;
		  hypot     = Math.hypot(deltaX,deltaY);
		  distanceX = interval[j]*deltaX/hypot;
		  distanceY = interval[j]*deltaY/hypot;
		  points[j].push(new Point(points[j][i].x + distanceX,
					   points[j][i].y + distanceY));
	      }
	      for (let j=0;j<s.container.length;j++) {
		  if (j==(s.container.length-1))
		      k=0;
		  else
		      k=j+1;
		  drawLine(points[j][i+1],points[k][i+1],s.color);
		  interval[j] -= intervalStep[j];
	      }
	  }
      }  // End drawSpiral

//////////////////////////////////////////////////////////////////
// drawTheodorusSpiral
//////////////////////////////////////////////////////////////////
    function drawTheodorusSpiral(thing,numTriangles) {
	context.strokeStyle = thing.color;
	context.lineWidth   = thing.lineWidth;

	// Scaling factor for visual size
	const scale = 50; 
	
	// Initial values
	let currentHypotenuse = 1; // Start with a leg of length 1
	let currentAngle      = 0; // Initial angle
	
	// FUNCTION TO DRAW A SINGLE TRIANGLE SEGMENT
	function drawTriangle(hypotenuseLength, angle) {
	    context.beginPath();
	    context.moveTo(thing.midpoint.x, thing.midpoint.y); // Start at the origin

	    // Calculate new vertex coordinates
	    const x = thing.midpoint.x + hypotenuseLength * scale * Math.cos(angle);
	    const y = thing.midpoint.y + hypotenuseLength * scale * Math.sin(angle);
	    
	    context.lineTo(x, y); // Draw hypotenuse
	    context.lineTo(x - scale * Math.sin(angle), y + scale * Math.cos(angle)); // Draw perpendicular leg (length 1)
	    context.closePath(); 
	    context.stroke(); // Draw the triangle outline
	}

	// Loop to draw the spiral
	for (let i = 1; i <= numTriangles; i++) {
	    // Calculate the angle of the new triangle based on the previous hypotenuse
	    const angleIncrement = Math.atan(1 / currentHypotenuse); 
	    currentAngle += angleIncrement;
	    
	    // Draw the current triangle
	    drawTriangle(Math.sqrt(i + 1), currentAngle); 
	    
	    // Update hypotenuse for the next iteration
	    currentHypotenuse = Math.sqrt(currentHypotenuse * currentHypotenuse + 1);
	}
    }

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// INDIRECT DRAW FUNCTIONS
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
// showBaseline
// NO LONGER USED
/////////////////////////////////////////////////////////////////
      function showBaseline(thing){
	  let oldColor = context.strokeStyle;
	  let lineWidth = context.lineWidth;
	  beginPath();
	  context.strokeStyle = "red";
	  context.lineWidth = 1;
	  
	  let end = thing.arm1.length-1;
	  moveTo(thing.arm1[0].x,  thing.arm1[0].y);
	  lineTo(thing.arm1[end].x,thing.arm1[end].y);
	  
	  end = thing.arm2.length-1;
	  moveTo(thing.arm2[0].x ,thing.arm2[0].y);
	  lineTo(thing.arm2[end].x,thing.arm2[end].y);
	  stroke();
	  closePath();

	  let num1 = thing.arm2[end].x.toFixed();
	  let num2 = thing.arm2[end].y.toFixed();
	  let text = `[${num1}, ${num2}]`;	
          context.fillStyle = "white";
	  context.font = "10px Arial";
	  context.fillText(text,num1, num2);
	  context.strokeStyle = oldColor;
	  context.lineWidth = lineWidth;
      } // end showBaseline

/////////////////////////////////////////////////////////////////
// stitcher
/////////////////////////////////////////////////////////////////
// MOVED
      function stitcher(thing){
	  if (thing.bendY) {
	      drawBendedArm(thing);
	      return;
	  }
	  let steps;
	  if (thing.shorten) {
	      tArm1 = thing.arm1;
	      tArm2 = thing.arm2;
	      shortenArms(thing);
	  }
 	  if (thing._bendSteps) {
	      steps = thing._bendSteps;
	  } else if (thing.trunc) {
	      steps = thing.trunc;
	      if (steps > thing.arm2.length) thing.arm2.length = steps;
	  } else {
	      steps = thing.arm1.length;
	  }
	  steps = steps - thing.endSkip;

	  _stitcher(thing.arm1,thing.arm2,thing.startSkip,steps,
		    thing.color,thing.lineWidth);
//          beginPath();
// 	  context.strokeStyle = thing.color;
//	  context.lineWidth   = thing.lineWidth;
//	  context.lineCap     = 'round';
//	  for (let i = thing.startSkip; i < steps; i++) {
//	      moveTo(thing.arm1[i].x,thing.arm1[i].y);
//	      lineTo(thing.arm2[i].x,thing.arm2[i].y);
//	      drawLine(thing.arm1[i],thing.arm2[i],thing.color);
//	  }
//	  stroke();
//	  closePath();
	  if (thing.shorten) {
	      thing.arm1 = tArm1;
	      thing.arm2 = tArm1;
	  }
//	  if (thing.showNodes) showNodes(thing);
      } // end stitcher


// MOVED
    function _stitcher(arm1,arm2,startSkip,steps,color,lineWidth){
          beginPath();
// 	  context.strokeStyle = color;
//	  context.lineWidth   = lineWidth;
//	  context.lineCap     = 'round';
	  for (let i = startSkip; i < steps; i++) {
//	      moveTo(arm1[i].x,arm1[i].y);
//	      lineTo(arm2[i].x,arm2[i].y);
	      drawLine(arm1[i],arm2[i],color);
	  }
//	  stroke();
//	  closePath();
    }
/////////////////////////////////////////////////////////////////
// drawBendedArm
/////////////////////////////////////////////////////////////////
// MOVED
      function drawBendedArm(thing){
	  // save orig
	  let tArm1      = thing.arm1;
	  let tArm2      = thing.arm2;
	  let tBendY     = thing.bendY;
	  thing.bendY    = false;
	  let tSteps     = thing.numSteps;

	  // since bend is at midpoint, just do half of points
	  thing._bendSteps = tSteps/2;
	  stitcher(thing);
	  thing._bendSteps = false;
	  //NOW BEGIN SECOND HALF
	  //arm1 points are unchanged, just get rid of pts already used
	  let length = thing.arm1.length;
	  if ((length % 2) == 1) length--;
	  let mid = length/2;
	  thing.arm1 = tArm1.slice(mid, tArm1.length);
	      
	  // divide hypot by 2 because bend is at the midpoint
	  let endY = tArm2.length-1;
	  let hypot = Math.hypot(tArm2[0].x - tArm2[endY].x,
				  tArm2[0].y - tArm2[endY].y)/2;
	  let halfArm2 = tArm2.slice(mid, tArm2.length);
	  // add new Y from bend; visual bend up is actually a
	  // negative Y
	  endY = halfArm2.length -1;
	  halfArm2[endY].y = halfArm2[endY].y-tBendY;
	      
	  let deltaY = halfArm2[endY].y - halfArm2[0].y;
	  // how long is X
	  let x = Math.sqrt(hypot*hypot - deltaY*deltaY);
	  halfArm2[endY].x = halfArm2[0].x + x;
	  thing.numSteps = thing.numSteps/2;
	  thing.newArm2 = ptsOnLine(thing.numSteps, halfArm2[0],halfArm2[endY]);
	  stitcher(thing);
	  
	  // restore orig
	  thing.bendY    = tBendY;
	  thing.numSteps = tSteps
	  thing.arms1    = tArm1;
	  thing.arms2    = tArm2;
      } // End Bended Arm



/////////////////////////////////////////////////////////////////
// drawCircle
/////////////////////////////////////////////////////////////////
      function drawCircle(midpoint,radius, color="black",width=1) {
          let oldWidth = context.lineWidth;
	  if (width==99)
	      lineWidth = 1;
	  else
	      lineWidth = width;
	  let oldColor  = context.strokeStyle;
	  context.strokeStyle = color;
          context.lineWidth = lineWidth;
	  context.beginPath();
	  context.arc(midpoint.x,midpoint.y, radius,0, (Math.PI/180)*360);
	  context.stroke();
 	  context.strokeStyle = oldColor;
	  context.lineWidth = oldWidth;
     } // end drawCircle
      
                      ////////////////////
                      // testCircle
                      ////////////////////
      function testCircle(pt,color="black",width=99) {
	  drawCircle(pt,5,color,width);
      } // end testCircle

///////////////////////////////////////////////////////////
// DRAW LINE
//    drawLine
//    drawLines
//    drawLinesAllAround
//    drawLinesAround
    
///////////////////////////////////////////////////////////
// MOVED
      function drawLine(point1,point2,color="blue",lineWidth=1) {
	  pt1 = numbersToPoints(point1);
	  pt2 = numbersToPoints(point2);
	  let oldLineWidth = context.lineWidth;
	  beginPath();
	  context.strokeStyle = color;;
	  context.lineWidth = lineWidth;
	  moveTo(pt1.x,pt1.y);
	  lineTo(pt2.x,pt2.y);
	  stroke();
	  closePath();
	  context.lineWidth = oldLineWidth;
      } // end drawLine

                      ////////////////////
                      // drawLines
                      ////////////////////
    function _drawLines(s) {
	if (!("start" in s)) s.start = 0;
	if (!("end"   in s)) s.end   = s.pts.length;
	if (!("color" in s)) s.color = "blue";
	if (!("close" in s)) s.close = false;
	if (!("skip"  in s)) s.skip   = 1;
	if (!("chop"  in s)) s.chop   = false;
	let i, j;
	for (i=s.start; i < s.end; i++) {
	    j = i + s.skip;
	    if (s.chop) {
		if (j >= s.pts.length)
		    return;
	    }
	    j = j % s.pts.length;
	    drawLine(s.pts[i],s.pts[j],s.color);
	}
 	if (s.close) {
	    drawLine(s.pts[0],s.pts[j],s.color);
	}
    }
    
    function drawLines(ptArray,start=0,end=ptArray.length,color="blue", close=false) {
	s = { pts:     ptArray,
	      start:   start,
	      end:     end,
	      skip:    1,
	      color:   color,
	      close:   false
	    };
	_drawLines(s);
   }

                      //////////////////////
                      // drawLinesAllAround
                      //////////////////////
    function drawLinesAllAround(ptArray,skip,color) {
	s = { pts:   ptArray,
	      skip:  skip,
	      color: color
	    };
	_drawLines(s);
    }

                      ////////////////////
                      // drawLinesAround
                      ////////////////////
    function drawLinesAround(ptArray,skip,color) {
	s = { pts:    ptArray,
	      skip:   skip,
	      color:  color,
	      chop:   true
	    };
	_drawLines(s);
//	let j = skip;
//	let i = 0;
//	while (j < ptArray.length) {
//	    drawLine(ptArray[i],ptArray[j],color);
//	    i++;
//	    j=i+skip;
//	}
    }
    
//////////////////////////////////////////////////////////////////
// drawNodes
//////////////////////////////////////////////////////////////////
    function drawNodes(pts,color) {
	ptNodes = numbersToPoints(pts);
	s={ pts:   ptNodes,
	    close: true,
	    color: color
	  };
//	alert(s.end);
	_drawLines(s);
    }

    
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
// createEllipseNodes
//    (x₀, y₀) is the center of the ellipse
//    'a' is the semi-major axis
//    'b' is the semi-minor axis
/////////////////////////////////////////////////////////////////
    function createEllipseNodes(thing) {
	if (thing.ellipse.a == thing.ellipse.b) 
	    return createNodes(thing);
	else
	    return getEllipsePts(thing);
//	let nodes     = getEllipsePts(thing);
//	let manyNodes = getEllipsePts(thing,10);
//	let circumference = ellipseCircumference(thing.ellipse.a,thing.ellipse.b);
//	let segLength = circumference/thing.numNodes;
	
	// Rather just take the points drawn on the ellipse using sine
	// and cosine, take the circumference and divide it by the
	// number of line segment that it might take to draw the ellipse.
	// If sufficiently large, this looks like an ellipse. Now figure
	// out the position of this segment against the 'ideal' ellipse by
	// taking the hypot beginning at a node going to the next in manyNodes.
	// Once this hypot is greater than the line segment, we know about
	// where the next node should be.
	//    Increasing the numerical argument to getEllipsePts means more
	// points between nodes, increasing the prescision. 10 seems good
	// enough.

//	let j = 0;
//	let newNodes=[];
//	total = 0;
//
//	while (total < segLength) {
//	    hypot = Math.hypot((manyNodes[j+1].x - manyNodes[j].x),
//			       (manyNodes[j+1].y - manyNodes[j].y));
//	    total += hypot;
//	    if (total > segLength) break;
//	    j++;
//	}
//	total = 0;
//	while (total < manyNodes.length -1) {
//	    newNodes.push(manyNodes[total]);
//	    total += j;	    
//	}
//	return newNodes;
//	return nodes;
    }




/////////////////////////////////////////////////////////////////
// createNodes
/////////////////////////////////////////////////////////////////
// MOVED
    function createNodes(thing) {
	let nodes =_createNodes(thing.numNodes,thing.rotate,thing.midpoint,
			    thing.radius,thing.xScale,thing.yScale);
//	if (thing.printNodes) printNodes(nodes,thing.numNodes);
	return nodes;
   } // end createNodes

// MOVED
    function _createNodes(numNodes,rotate,midpoint,radius,xScale,yScale) {
	let angleInc    = 2*Math.PI/numNodes;
	let rotatedAngle= toRadians(rotate);
	let newAngle    = rotatedAngle;
	let nodes       = [];

	// figure out nodes
	for (let i=0; i < numNodes; i++) {
            nodes.push(new Point(midpoint.x + radius*Math.cos(newAngle),
				 midpoint.y - radius*Math.sin(newAngle)));
	    newAngle = newAngle+angleInc;
	}
 	if (!(xScale == 1 && yScale == 1)){
	    nodes = _scaleNodes(nodes, xScale, yScale, midpoint)
	}
   return nodes;  
} // end _createNodes

//////////////////////////////////////////////////////////////////
// CREATE PRINT NODES
//////////////////////////////////////////////////////////////////
     function createPrintNodes(s) {
	let nodes =_createNodes(s.numNodes,s.rotate,s.midpoint,
				s.radius,s.xScale,s.yScale);
	 let size = gl.pts.length;
	 for (let i=0; i < nodes.length; i++) {
	     printCircNum(nodes[i],i+size);
	     printANode(nodes[i],i);
	     gl.pts.push(nodes[i]);
	 }
			  
	if (s.mid) {
	    gl.newLine += 12;
	    printText("Midpoint");
	    gl.newLine += 12;
	    for (let i=0; i < nodes.length; i++) {
		j=i+1;
		if (j==nodes.length) j=0;
		mid = midpoint(nodes[i],nodes[j]);
		gl.pts.push(mid);
		printCircNum(mid);
		printANode(mid);
		n1x = nodes[i].x.toFixed();
		n1y = nodes[i].y.toFixed();
		n2x = nodes[j].x.toFixed();
		n2y = nodes[j].x.toFixed();
		text=`${i}: (${n1x},${n1y},   (${mid.x.toFixed()},${mid.y.toFixed()}),   (${n2x},${n2y})`;
		printText(text);
	    }
	}
	 return nodes;
     }


//////////////////////////////////////////////////////////////////
// crossHair
//////////////////////////////////////////////////////////////////
    function crossHair(pts, color) {
	let points = numbersToPoints(pts);
	for (let i=0; i < points.length; i++) {
	    drawLine(new Point(points[i].x-20, points[i].y),
		     new Point(points[i].x+20, points[i].y),
		     color,3);
	    drawLine(new Point(points[i].x,    points[i].y-20),
		     new Point(points[i].x,    points[i].y+20),
		     color,3);
	}
    } // end crossHair


//////////////////////////////////////////////////////////////////
// ellipseCircumference
//////////////////////////////////////////////////////////////////
    function ellipseCircumference(a, b) {
	// a: semi-major axis
	// b: semi-minor axis
	
	if (a <= 0 || b <= 0) {
	    throw new Error("Semi-major and semi-minor axes must be positive values.");
	}

	const term1 = 3 * (a + b);
	const term2 = Math.sqrt((3 * a + b) * (a + 3 * b));
	const circumference = Math.PI * (term1 - term2);

	return circumference;
    }


/**
 * Generate points along the circumference of a rotated ellipse.
 *
 * @param {number} width - Total width of the ellipse (major axis).
 * @param {number} height - Total height of the ellipse (minor axis).
 * @param {number} cx - X-coordinate of the ellipse center.
 * @param {number} cy - Y-coordinate of the ellipse center.
 * @param {number} rotation - Rotation angle of the ellipse in radians.
 * @param {number} numPoints - Number of points to generate.
 * @returns {Array<{x: number, y: number}>} - Array of (x,y) points.
 */
 function ellipsePts(thing) {
     let width     = thing.ellipse.a;
     let height    = thing.ellipse.b;
     let cx        = thing.midpoint.x;
     let cy        = thing.midpoint.y;
     let rotation  = toRadians(thing.rotate);
     let numPoints = thing.numNodes;
     let cosR      = Math.cos(rotation);
     let sinR      = Math.sin(rotation);
     let angleInc  = 2*Math.PI/numPoints;

     const points = [];
     const a = width / 2;   // semi-major axis
     const b = height / 2;  // semi-minor axis

  for (let i = 0; i < numPoints; i++) {
    // Parametric angle for ellipse
    const theta = angleInc * i;

    // Point on unrotated ellipse
    const x0 = a * Math.cos(theta);
    const y0 = b * Math.sin(theta);

    // Apply rotation
    const xr = x0 * cosR - y0 * sinR;
    const yr = x0 * sinR + y0 * cosR;

    // Translate to center
      points.push(new Point(cx + xr, cy + yr));
    }

  return points;
 }



//////////////////////////////////////////////////////////////////
// getEllipsePts
//////////////////////////////////////////////////////////////////
    function getEllipsePts(thing,factor=1) {
	if (thing.rotate == 0)
	    thing.rotate=90;
	let angleInc     = 2*Math.PI/(factor*thing.numNodes);
	let rotation     = toRadians(thing.rotate);
	let cosR         = Math.cos(rotation);
	let sinR         = Math.sin(rotation);
	let newAngle     = 3*Math.PI/2;
	const nodes  = [];
	let a            = thing.ellipse.a;
	let b            = thing.ellipse.b;
	// x_rotated = cx + (rx * cos(t) * cos(theta)) -
	//                  (ry * sin(t) * sin(theta))
	// y_rotated = cy + (rx * cos(t) * sin(theta)) +
	//                  (ry * sin(t) * cos(theta))
	for (let i=0; i < thing.numNodes*factor; i++) {
	    x = thing.midpoint.x +
		a * Math.cos(newAngle) * cosR -
	        b * Math.sin(newAngle) * sinR;
	    y = thing.midpoint.y +
		a * Math.cos(newAngle) * sinR -
	        b * Math.sin(newAngle) * cosR;
	    nodes.push(new Point(x,y));
	    newAngle += angleInc;
	}
	return nodes;  
      } // end getEllipsePts
    
/////////////////////////////////////////////////////////////////
// get ellipse nodes
/////////////////////////////////////////////////////////////////
      function getEllipseNodes(s) {
	  // x = h+a*sin(t);
	  // y = k+b*cos(t)
	  // a is the radius along the x-axis
	  //    half the width of ellipse
	  // b is the radius along the y-axis
	  //    half the height of ellipse
	  // h,k are the x and y coordinates of midpoint
	  // t ranges from0 to 2^PI
  	  let width = s.width/2;
	  let height = s.height/2;
	  let interval = 2*Math.PI/s.numNodes;
	  let nodes = [];
	  const nodes1 = [];
	  let x, y;
	  for (i=0; i < s.numNodes -1; i++){
	      nodes.push(new Point(s.midX +  width*Math.sin(interval),
				   s.midY + height*Math.cos(interval)));
	      nodes1.push(new Point(s.midX -  width*Math.sin(interval),
				    s.midY - height*Math.cos(interval)));
	      interval += interval;
	  }
	  nodes = nodes.concat(nodes1);
          return nodes;
      }

/////////////////////////////////////////////////////////////////
// pointsOnParabola
//      returns an array of points that are the points on the
//      parabola in addition to drawing the partial parabola.
//      Notice the "cutoff" element in "thing", which is the
//      number of lines to draw.
/////////////////////////////////////////////////////////////////
      function pointsOnParabola(thing,Parab){
	  if (Parab.length == 3)
	      Parab.splice(1,0, Parab[1]);
	  parab = numbersToPoints(Parab);
	  thing.arm1 = ptsOnLine(thing.numSteps, parab[0], parab[1]);
	  thing.arm2 = ptsOnLine(thing.numSteps, parab[2], parab[3]);
	  arm3 = [];
	  for (i=0; i < thing.arm1.length-1; i++){
              p1 = thing.arm1[i];
	      p2 = thing.arm2[i];
	      p3 = thing.arm1[i+1];
	      p4 = thing.arm2[i+1];
	      arm3.push(lineIntersect(thing.arm1[i],thing.arm2[i],
				      thing.arm1[i+1],thing.arm2[i+1]));
	  }
	  thing.arm1 = arm3;
	  steps = thing.numSteps;
	  thing.numSteps = thing.cutoff;
	  stitcher(thing);
	  thing.numSteps = steps;
	  return arm3;
      } // end pointsOnParabola

      // WHY NUMNODES AREGUMENT. need to rethink given arm1 and arm2
/////////////////////////////////////////////////////////////////
// Print Functions      
//    printANode
//    printCircNum
//    printNodes
//    printText
//    printTitle
/////////////////////////////////////////////////////////////////
                   /////////////////////
                   // printANode
                   /////////////////////
    function printANode(pt,num=999) {
	let x = 510;
	let ctr;
    	if (num==999) ctr=gl.ctr;
	else ctr=num;
	let text = `${ctr}=(${pt.x.toFixed()}, ${pt.y.toFixed()})`;
        context.fillText(text,x,gl.newLine);
	gl.newLine += 12;
    }
    
                   /////////////////////
                   // printCircNum
                   /////////////////////
    function printCircNum(point,num=999) {
	pt = numbersToPoints(point);
	let newPt = new Point(pt.x,pt.y);
	if (gl.final) {
	    if (num==999) gl.ctr++;
	    return;
	}
	drawCircle(newPt,8,"black");
	let oldFillStyle = context.fillStyle;
	context.fillStyle = "black";
	context.textAlign = 'center';
	context.textBaseline = 'middle';
	if (num==999) {
	    context.fillText(gl.ctr,newPt.x,newPt.y);
	    gl.ctr++;
	} else 
	    context.fillText(num,newPt.x,newPt.y);
	context.fillStyle = oldFillStyle;
    }
    

                   /////////////////////
                   // printText
                   /////////////////////
    function printText(text) {
 	let color         = context.fillStyle;
	context.fillStyle = "blue";
	let x = 500; 
        context.fillText(text,x,gl.newLine);
	context.fillStyle = color;
	gl.newLine += 12;
    }
    
                   /////////////////////
                   // printTitle
                   /////////////////////
//    function printTitle(text,pt=new Point(150,20),col="blue") {
//	x = pt.x; y=pt.y;
// 	let color         = context.fillStyle;
//	let font          = context.font;
//	context.font      = "12px Verdana";
//	context.fillStyle = col;
//        context.fillText(text,x,y);
//	context.fillStyle = color;
//	context.font      = font;
//    }

/////////////////////////////////////////////////////////////////
// showNodes
/////////////////////////////////////////////////////////////////
//    function showNodes(thing) {
//          let color = context.fillStyle;
//	  context.fillStyle = "blue";
//          let text = `(${thing.arm1[0].x.toFixed()}, ${thing.arm1[0].y.toFixed()})`;
//	  context.fillText(text,thing.arm1[0].x, thing.arm1[0].y);
//          text = `(${thing.arm2[1].x.toFixed()}, ${thing.arm2[1].y.toFixed()})`;
//	  context.fillText(text,thing.arm2[1].x, thing.arm2[1].y);
//	  context.fillStyle=color;
//      }

	  
    
/////////////////////////////////////////////////////////////////
// ptsOnLine
/////////////////////////////////////////////////////////////////
    function ptsOnLine(numSteps,start,end) {
	let xInc = (end.x - start.x)/numSteps;
	let yInc = (end.y - start.y)/numSteps;
	let aPt = new Point(start.x, start.y);
	const pts = [];
	pts.push(new Point(aPt.x, aPt.y));
	for (let i = 0; i < numSteps; i++) {
	    aPt.x += xInc;
	    aPt.y += yInc;
	    pts.push(new Point(aPt.x, aPt.y));
	}
        return pts;	  
    } // end ptsOnLine


 
/////////////////////////////////////////////////////////////////
// scaleNodes
/////////////////////////////////////////////////////////////////
    function scaleNodes(nodes, thing) {
	return _scaleNodes(nodes, thing.xScale, thing.yScale,
			   thing.midpoint);
    }

    function _scaleNodes(nodes, xScale, yScale, midpoint){
	if (xScale != 1){
	for (let i=0; i < nodes.length; i++){
	    nodes[i].x = midpoint.x + 
		xScale*(midpoint.x - nodes[i].x);
	}
	}
	if (yScale != 1) {
	    for (let i=0; i < nodes.length; i++){
		nodes[i].y = midpoint.y - 
		    yScale*(midpoint.y - nodes[i].y);
	    }	  
	}
	return nodes;
    } // end scaleNodes

/////////////////////////////////////////////////////////////////
// setPt
/////////////////////////////////////////////////////////////////
    function setPt(pt,draw=true) {
        gl.pts.push(pt);
	if (draw)
	    printCircNum(pt);
	return gl.pts.length - 1;
    }
    
/////////////////////////////////////////////////////////////////
// shortenArms
/////////////////////////////////////////////////////////////////
// MOVED
    function shortenArms(thing) {
	              // thing.shorten is the percent to shorten.
	              // I want the amount left
	let shorten = (100 - thing.shorten)/100;
	let deltaX = Math.abs(thing.arm1[thing.arm1.length-1].x - thing.arm1[0].x);
//	if (deltaX == 0) 
//	    deltaX = 100;
	let length = shorten*deltaX;
	let j = 0;
	for (let i=0; i < thing.arm1.length -1; i++) {
	    deltaX = Math.abs((thing.arm1[i].x - thing.arm1[0].x));
	    if (deltaX > length ) {
		j = i;
		break;
	    }
	}
	if (j==0) j=thing.arm1.length -1;;
	thing.arm1.length=j;
	thing.arm2.splice(j,thing.arm2.length-1);
	if (thing.arm2.length < thing.arm1.length)
	    thing.arm2.splice(0,j-1);
    }

//////////////////////////////////////////////////////////////////
// showColors
//////////////////////////////////////////////////////////////////
    function showColors(col,xPos=0, yPos=0) {

	function printLabel(text,x,y) {
 	    let color         = context.fillStyle;
	    let font          = context.font;
	    context.font      = "15px Verdana";
	    context.fillStyle = "blue";
            context.fillText(text,x,y+30);
	    context.fillStyle = color;
	    context.font      = font;
	}

	let color      = colourNameToHex(col);
//	printTitle("showColors--Tints and shades: " + col);
	let startY     = yPos + 30;
	let x          = xPos + 10;
	let tintAmount = .12;
	colors = [];
	for (let i=0; i<8; i++) {
	    newColor    = calculateTintAndShade(color,tintAmount);
	    tintAmount += .1;
	    context.fillStyle = newColor.tint.hex;
	    colors.push({color: newColor.tint.hex, tint: tintAmount.toFixed(2)});
	    context.fillRect(x,startY,190,70);
	    printLabel("Tint: " + tintAmount.toFixed(2),x+200,startY);
	    printLabel(newColor.tint.hex,               x+200,startY+18);
	    startY += 70;
	}
	startY = yPos + 30;
	x=x+300;
	tintAmount = .08;
	  
  	for (let i=0; i<8; i++) {
	    newColor    = calculateTintAndShade(color,tintAmount);
	    tintAmount += .04;
	    context.fillStyle = newColor.shade.hex;
	    colors.push({color: newColor.shade.hex, shade: tintAmount.toFixed(2)});
	    context.fillRect(x,startY,190,70);
	    printLabel("Shade: " + tintAmount.toFixed(2),x+200,startY);
	    printLabel(newColor.shade.hex,               x+200,startY+18);
	    startY += 70;
	}
	return colors;
    }


/////////////////////////////////////////////////////////////////
// draw Circular Parabola
/////////////////////////////////////////////////////////////////
// MOVED
      function drawCircularParabola(thing) {
	  let pt         = new Point(thing.midpoint.x, thing.midpoint.y);
	  const nodes    = createNodes(thing);
	  // numNodes equals total number of steps around circle
	  let numNodes   = thing.numNodes;
	  thing.numNodes = thing.numNodes*thing.numSteps;
          const ptNodes  = createNodes(thing);
	  drawNodes(ptNodes,thing.color);
	  arm2 = [];
	  arm3 = [];
	  base = 0;
	  // create an array where each element is a part of the circle
	  for (i=0; i < numNodes; i++) {
	      pts = [];
	      let k;
              for (j = 0; j < thing.numSteps+1; j++) {
		  k = (base+j) % thing.numNodes;
		  pts.push(ptNodes[k]);
	      }
	      base += thing.numSteps;
	      arm2.push(pts);
	  }
          thing.numNodes = numNodes;
	  for (let i=0; i < thing.numNodes; i++) {
	      j = i % thing.numNodes;
	      thing.arm1 = ptsOnLine(thing.numSteps,thing.midpoint,nodes[j]);
	      thing.arm2 = arm2[i];
	      stitcher(thing);
	      if (thing.both) {
		  j = i-1;
		  if (j < 0) j = thing.numNodes-1;
		  thing.newArm2 = arm2[j].toReversed();
		  stitcher(thing);
	      }
	  }
      } // end drawCircularParabola


//////////////////////////////////////////////////////////////////
// Replace: moveTo, lineTo, beginPath, closePath, stroke
//////////////////////////////////////////////////////////////////
// MOVED
    function moveTo(pt1,pt2) {
	if (gl.dot) {
	    drawCircle(new Point(pt1,pt2),1);
	} else {
	    context.moveTo(pt1,pt2)
	}
    }
// MOVED
    function lineTo(pt1,pt2) {
	if (gl.dot) {
	    drawCircle(new Point(pt1,pt2),1);
	} else {
	    context.lineTo(pt1,pt2)
	}
    }
// MOVED
    function beginPath() {
	if (!gl.dot) context.beginPath();
    }
    
// MOVED
    function stroke(){
	if (!gl.dot) context.stroke();
    }
    
// MOVED
    function closePath() {
	if (!gl.dot) context.closePath();
    }

/////////////////////////////////////////////////////////////////
// drawInverseStar
/////////////////////////////////////////////////////////////////
// MOVED
      function drawInverseStar(thing) {
  	  let nodes = createNodes(thing);
	  nodes.unshift(nodes[thing.numNodes-1]);
	  const parabs1 = [];
	  const parabs2 = [];
	  for (let i=1; i<thing.numNodes+1; i++){
	      m = i;
	      j = i-1;
	      k = i+1;
	      if (m >= thing.numNodes) m = m % thing.numNodes;
	      if (j >= thing.numNodes) j = j % thing.numNodes;
	      if (k >= thing.numNodes) k = k % thing.numNodes;
	      parabs1.push([thing.midpoint,nodes[m],nodes[j]]);
	      parabs2.push([thing.midpoint,nodes[m],nodes[k]]);
	  }
	  drawParabs(thing,parabs1);
	  drawParabs(thing,parabs2);
      } //end drawInverseStar

/////////////////////////////////////////////////////////////////
// drawRegularPolygon
/////////////////////////////////////////////////////////////////
// MOVED
      function drawRegularPolygon(thing) {
  	  let nodes    = createNodes(thing);
	  const parabs = [];
	  for (let i=0; i<thing.numNodes; i++){
	      k = i + 1;
	      l = i + 2;
	      if (k >= thing.numNodes) k = k % thing.numNodes;
	      if (l >= thing.numNodes) l = l % thing.numNodes;
	      parabs.push([nodes[i],nodes[k],nodes[l]]);
	  }
	  drawParabs(thing,parabs);
     }  // End DrawPolygon

/////////////////////////////////////////////////////////////////
// drawRegularPolygonTouch
/////////////////////////////////////////////////////////////////
// MOVED
      function drawRegularPolygonTouch(thing) {
  	  let nodes    = createNodes(thing);
	  const parabs = [];
	  let length = thing.numNodes;
	  if ((length % 2) == 1) length--;
	  for (let i=0; i<length; i+=2){
	      j = i+2;
	      if (j==thing.numNodes) j = 0;
	      parabs.push([nodes[i],nodes[i+1],nodes[j]]);
	  }
	  drawParabs(thing,parabs);
     }  // End DrawPolygon

/////////////////////////////////////////////////////////////////
// drawRegularStar`
/////////////////////////////////////////////////////////////////
// MOVED
       function drawRegularStar(thing) {
  	  let nodes = createNodes(thing);	
	  const lineEnd = [];
	  let deltaX, deltaY,newX,newY;
	  for (let i=0;i<thing.numNodes;i++){
	      deltaX=thing.midpoint.x - nodes[i].x;
	      deltaY=thing.midpoint.y - nodes[i].y;
	      newX = thing.midpoint.x - thing.factor*deltaX;
	      newY = thing.midpoint.y - thing.factor*deltaY;
	      lineEnd[i] = new Point(newX,newY);
	  }
	  parabs = [];
	  for (i=0;i<thing.numNodes;i++) {
	      if (i==thing.numNodes-1) j=0; else j = i+1;
	      parabs.push([nodes[i],lineEnd[i],lineEnd[j],nodes[j]]);
	  }
	  drawParabs(thing,parabs);
       } // end drawRegularStar

/////////////////////////////////////////////////////////////////
// drawRegularPolygonCorner
/////////////////////////////////////////////////////////////////
// MOVED
      function drawRegularPolygonCorner(thing) {
  	  let nodes    = createNodes(thing);
	  const parabs = [];
	  for (let i=0; i<thing.numNodes; i++){
	      k = i + 1;
	      l = i + 2;
	      if (k >= thing.numNodes) k = k % thing.numNodes;
	      if (l >= thing.numNodes) l = l % thing.numNodes;
	      ptA = new Point(nodes[k].x - (nodes[k].x - nodes[l].x)/2,
			      nodes[k].y - (nodes[k].y - nodes[l].y)/2);
	      ptB = new Point(nodes[k].x - (nodes[k].x - nodes[i].x)/2,
			      nodes[k].y - (nodes[k].y - nodes[i].y)/2);
	      parabs.push([ptA,nodes[k],ptB]);
	  }
	  drawParabs(thing,parabs);
     }  // End DrawPolygon









/////////////////////////////////////////////////////////////////
// background
/////////////////////////////////////////////////////////////////
// MOVED
      function background (color="lightblue", grid=false) {
	  let canvas         = document.querySelector("#StringThing");
	  let width          = canvas.width;
	  let height         = canvas.height;
	  let oldColor       = context.strokeStyle;
	  context.fillStyle  = color;
	  context.strokeStyle= "PapayaWhip";
	  context.lineWidth  = 1;
          context.fillRect(0,0,width,height);

	  if (grid) {
	      let steps = width/25;
	      let xPoint = 25;
	      for (let i=0; i < steps; i++) {
		  beginPath();
		  moveTo(xPoint,0);
		  lineTo(xPoint,height);
		  xPoint=xPoint+25;
		  stroke();
		  closePath();
	      }

	      steps = height/25;
	      let yPoint = 25;
	      for (let i=0; i < steps; i++) {
		  beginPath();
		  moveTo(0,yPoint);
		  lineTo(width,yPoint);
		  yPoint=yPoint+25;
		  stroke();
		  closePath();
	      }
	  }
	  context.strokeStyle = "black";

      } //end background


/////////////////////////////////////////////////////////////////
// testBed
/////////////////////////////////////////////////////////////////
                   ///////////////////////////////////
                   // test 1:  DRAW RIGHT TRIANGLE
                   ///////////////////////////////////
// MOVED
      function test1() {
	  printTitle("Test1: Couple of Parabolas");
	  s = { numSteps: 20 };
	  thing = new StringThing(s);
	  coord1 = new Point(5,5);     coord2 = new Point(200,200);
	  coord1a= new Point(5,200);
	  coord3 = new Point(50,50);   coord4 = new Point(250,250);
	  coord3a= new Point(50,250);
	  parabs = [[coord1,coord1a,coord2],
		    [coord3,coord3a,coord4]];
	  drawParabs(thing,parabs);
	  context.fillStyle = "blue";
      }

                   ///////////////////////////////////
                   // test 2:  DRAW REGULAR
                   ///////////////////////////////////
    function test2() {
	printTitle("Test 2: Regular Shapes");
//	gl.dot = true;
	  s={numSteps:     20,
	     midpoint:     new Point(200,200),
//	     lineWidth:    .5,
//	     rotate:       45,
	     radius:       100,
//	     yIncrement:   .8,
//	     xScale:     1.2,
//	     yScale:     .5,
	     color:        "green",
	     numNodes:     4 };
	  thing = new StringThing(s);
//	  drawRegularStar(thing);
	  
	  thing.newColor = "blue";
	  thing.midpoint = new Point(420,200);
//	  drawInverseStar(thing);
	  
	  thing.newColor = "red";
	  thing.midpoint = new Point(200,420);
//	  drawRegularPolygon(thing);
	  
	  thing.newColor = "blue";
	  thing.midpoint = new Point(200,200);
	  drawRegularPolygonCorner(thing);
	  
	  thing.newColor = "orange";
	  thing.midpoint = new Point(420,200);
	  drawRegularPolygonTouch(thing);
	  
	  context.fillStyle = "blue";
	  context.fillText("Draw Regular Star",   10,10);
	  context.fillText("Draw Inverse Star",   10,20);
	  context.fillText("Draw Regular Polygon",10,30);
	  context.fillText("Draw Regular Polygon Corner",10,40);
	  context.fillText("Draw Regular Polygon Touch", 10,50);
	  context.fillText("  lineWidth",       10,70);
	  context.fillText("  midpoint",        10,80);
	  context.fillText("  numSteps",        10,90);
	  context.fillText("  radius",          10,110);
	  context.fillText("  rotate",          10,120);
	  context.fillText("  yIncrement: best with just parabolas",10,140);
	  context.fillText("  xScale",        10,150);
	  context.fillText("  yScale",        10,160);
      }

                   ///////////////////////////////////
                   // test 3:  DRAW CIRCLE
                   ///////////////////////////////////
    function test3() {
	printTitle("Test 3: Draw Circle");
	  test5();
	  let center = new Point(30,10);
	  drawCircle(center);
      }

                   ///////////////////////////////////
                   // test 4:  DRAW MANY PARABS
                   ///////////////////////////////////
    function test4() {
	  coord1 = new Point(50,0);       coord11=new Point(300,10);
	  coord2 = new Point(50,400);     coord12=new Point(350,200);
	  coord3 = new Point(150,182.5);  coord13=new Point(500,100);
          coord4 = new Point(100,300);    coord14=new Point(400,400);
	  coord20 = new Point(35, 40);
	  coord21 = new Point(275, 110);
	  coord22 = new Point(25, 230);
	  coord23 = new Point(100, 530);
	  coord30 = new Point(50, 50);
	  coord31 = new Point(50, 400);
	  coord32 = new Point(400,400);

//	printTitle("Test 4a: Draw Many Parabolas");
//	  parabs = [[coord21, coord20, coord22, coord23]];

//	printTitle("Test 4b: Draw Many Parabolas");
//	  parabs = [[coord1, coord2, coord3],
//		    [coord21, coord20, coord22, coord23],
	//		    [coord11,coord12,coord13]];
	
	printTitle("Test 4c: Draw Many Parabolas");
	  parabs = [[coord30, coord31, coord32]];
	  
	  s = {
//	      yIncrement: .75,
//	      bendY: 100,
	      numSteps: 20,
	      color:    "blue"
	  }
	  thing = new StringThing(s);
	  drawParabs(thing,parabs);
      }

                   ///////////////////////////////////
                   // test 6:  DRAW RADIATE
                   ///////////////////////////////////
    function test6() {
	printTitle("Test 6: DrawRadiate");
	let numSteps = 30;
        let start = new Point(20, 20);
        let end   = new Point(400,100);
	let nodes = ptsOnLine(numSteps,start,end);
	let r     = {start:     new Point(300,300),
		     numSteps:  30,
		     lineWidth: 1,
		     nodes:     nodes,
		     color:     "blue"
		    };
	let thing = new StringThing(r);
	drawRadiate(thing);
      }

                   ///////////////////////////////////
                   // test 7:  ARC POINTS
                   ///////////////////////////////////
    function test7() {
	printTitle("Test 7: Arc Points");
	  s = {numSteps: 25,
	       color: "blue",
	       lineWidth: 1
	      };
	  thing      = new StringThing(s);	
          start      = new Point(10,300);
	  end        = new Point(200,10);
	  thing.arm1 = ptsOnLine(thing.numSteps,start,end);
          start      = new Point(200,10);
	  end        = new Point(400, 300);
	  thing.arm2 = arcPoints(start, end, .3, thing.numSteps);
	  stitcher(thing);

	  thing.newColor = 'green';
	  start      = new Point(10,500);
	  end        = new Point(200,210);
          thing.arm1 = arcPoints(start,end,.2,thing.numSteps);
          start      = new Point(200,210);
	  end        = new Point(400, 500);
	  thing.arm2 = arcPoints(start, end, .3, thing.numSteps);
	  stitcher(thing);
     }
                   ///////////////////////////////////
                   // test 8: DRAW ON PARABOLA
                   ///////////////////////////////////
    function test8() {
	printTitle("Test 8: Draw using points on parabola");
	  coord1 = new Point(0,0);       
	  coord2 = new Point(0,400);     
	  coord3 = new Point(200,400);
	  parab = [coord1, coord2, coord3];
	  s = {numSteps: 25,
	       cutoff: 8,
	       color: "darkblue"}
	  thing = new StringThing(s);
	  pointsOnParabola(thing,parab);

	  coord1 = new Point(210,0);       
	  coord2 = new Point(210,400);     
	  coord3 = new Point(400,400);	  
	  parab = [coord1, coord2, coord3];
	  thing.newColor = "green";
	  const ptsOnParab = pointsOnParabola(thing,parab);
	  context.fillStyle = "blue";
	  text = "Number points on Parab = "+ptsOnParab.length;
	  context.fillText(text,30,430);
      }

                   ///////////////////////////////////
                   // test 9:  DRAW EQUAL CHORDS
                   ///////////////////////////////////
    function test9() {
	printTitle("Test 9: Equal Chords");
	radius = 150;
	center = new Point(200,200);
	s = { midpoint: center,
	      numNodes: 40,
	      skip:     33,
	      color:    "blue",
	      withinCirc: FULL,
	      radius:   radius };
	thing = new StringThing(s);
	drawCircle(center,radius,"blue");
	drawInCircle(thing);
    }

                   ///////////////////////////////////
                   // test 10: MYSTIC ROSE
                   ///////////////////////////////////
    function test10 () {
	printTitle("Test 10: Mystic Rose, nodes 20");
	  s = { numNodes: 20,
		color:    "blue",
		midpoint: new Point(300,300),
		radius:   200};
	gl.final = true;
	  thing = new StringThing(s);
          drawMysticRose(thing);
      }

                   ///////////////////////////////////
                   // test 11: TWO LINKED CIRCLES
                   ///////////////////////////////////
    function test11(){
	printTitle("Test 11a: Two Linked Circles");
	  cir2 = {
//	      mid1: new Point(220,240),
//	      mid2: new Point(420,240),
//	      mid2: new Point(360,740),
	      
	      mid1: new Point(220,200),	      
	      mid2: new Point(360,660),
	      numPoints: 40,  
	      numSteps: 15,
	      color:    "blue",
	      radius: 200
	  }
	  drawTwoLinkedCircles(cir2);
      }

                   ///////////////////////////////////
                   // test 12: CIRCULAR PARABOLA
                   ///////////////////////////////////
    function test12(){
	printTitle("Test 12b: Circular Parabola");
	  s = { numNodes: 6,
		numSteps: 40,
		both: true,
		midpoint: new Point(420,320),
		radius:   300,
		color:    "blue"
	      }
	  thing = new StringThing(s);
	  drawCircularParabola(thing);
      }      

                   ///////////////////////////////////
                   // test 13: COLOR TEST
                   ///////////////////////////////////
      function test13() {
	  printTitle("Test 13: Color shading");
	  let color      = colourNameToHex("green");
	  let startY     = 30;
	  let tintAmount = .12;
	  for (let i=0; i<8; i++) {
	      newColor    = calculateTintAndShade(color,tintAmount);
	      tintAmount += .1;
	      context.fillStyle = newColor.tint.hex;
	      context.fillRect(10,startY,200,80);
	      startY += 80;
	  }
	  startY = 30;
	  tintAmount = .08;
	  
  	  for (let i=0; i<8; i++) {
	      newColor    = calculateTintAndShade(color,tintAmount);
	      tintAmount += .04;
	      context.fillStyle = newColor.shade.hex;
	      context.fillRect(240,startY,200,80);
	      startY += 80;
	  }	      }

                   ///////////////////////////////////
                   // test 14: CYCLOID
                   ///////////////////////////////////
    function test14() {
	printTitle("Test 14e: Cycloids 2 nodes, stretched,both");
	  s = { numNodes:   240,
		midpoint:   new Point(400, 320),
		color:      "blue",
		numCycloids: 2,
		xScale:    1.3,
		yScale:    .8,
		radius:      300
	      }

	  thing = new StringThing(s);
	  drawCycloid(thing);
      }

                   ///////////////////////////////////
                   // test 15: ELLIPSE NODES
                   ///////////////////////////////////
    function test15() {
	printTitle("Test 15: Ellipse Nodes");
	  s = { width: 400,
		height: 200,
		midX: 300,
		midY: 200,
		numNodes: 100
	      }
	  let nodes = getEllipseNodes(s);
          beginPath();
 	  context.strokeStyle = "blue";
	  context.lineWidth   = 1;
	  context.lineCap     = 'round';
	  let j = s.numNodes/2;
	  for (i=0; i < s.numNodes; i++, j++) {
	      moveTo(nodes[i].x,nodes[i].y);
	      lineTo(nodes[j].x,nodes[j].y);
	  }
	  stroke();
	  closePath();
      }

                   ///////////////////////////////////
                   // test 16: CROSSHAIR
                   ///////////////////////////////////
    function test16() {
	printTitle("Test 16: Crosshair");
	  crossHair([new Point(60,60)], "green");
      }
      
                   ///////////////////////////////////
                   // test 17: FULL ELLIPSE
                   ///////////////////////////////////
    function test17() {
	printTitle("Test 17: Ellipse");
	s = { centerX:  200,
	      centerY:  150,
	      color:    blue,
	      skip:     30,
	      ellipse:  {a: 100, b: 200},
	      numNodes: 100,
	      rotate:   90
	    };
	thing = new StringThing(s);
        drawInEllipse(thing);
      }

                   ///////////////////////////////////
                   // test 18: PURSUIT
                   ///////////////////////////////////
    function test18() {
	printTitle("Test 18: Pursuit--control dispersion by adjusting speed");
	  const rabbitStart = { x: 100, y: 50 };
	  const foxStart    = { x: 50, y: 400 };
	  const rabbitSpeed = 28;
	  const foxSpeed    = 32;
	  const timeStep = .5;
	  const maxIterations = 1000;
	  drawPursuitCurve(rabbitStart, foxStart, rabbitSpeed, foxSpeed,
				       timeStep, maxIterations);
      }

                   ///////////////////////////////////
                   // test 19: TWISTED ARMS
                   ///////////////////////////////////
    function test19() {
	printTitle("Test 19: Twisted Arms");
 	  coord20 = new Point(150, 20);
	  coord21 = new Point(500, 80);
	  coord22 = new Point(175, 250);
	  coord23 = new Point(300, 500);
	  parabs = [[coord21, coord20, coord22, coord23]];
	  s = {
	      bendY: 200,
	      numSteps: 30,
	      color:    "green"
	  }
	  thing = new StringThing(s);
	  drawParabs(thing,parabs);
     }




      
                   ///////////////////////////////////
                   // test 20: SPIRAL
                   ///////////////////////////////////
    function test20(){
	printTitle("Test 20: Spiral");
	  s = { color:     "blue",
		interval:  20,
//	      interval: [25,18,21,24],
		numSteps:  30
	      };	  // funny triangle
//	  printText("Funny Triangle");
	  coord100  = new Point(300,100);
	  coord101  = new Point(500,450);
	  coord102  = new Point(300,250);
	  coord103  = new Point(100,450);
	  s.container   = [coord100,coord101,coord102,coord103];
	  // box
//	  printText("Box");
	  coord110 = new Point(100,100);
	  coord111 = new Point(500,100);
	  coord112 = new Point(500,500);
	  coord113 = new Point(100,500);
	  s.container    = [coord110,coord111,coord112,coord113];
	  // box in different position
//	  printText("Box in different position");
	  coord120 = new Point(250,50);
	  coord121 = new Point(500,275);
	  coord122 = new Point(250,500);
	  coord123 = new Point(0,275);
	  s.container    = [coord120,coord121,coord122,coord123];
	  // cruciform
	  printText("Cruciform");
	  coord1  = new Point(200,100);
	  coord2  = new Point(300,100);
	  coord3  = new Point(300,200);
	  coord4  = new Point(400,200);
	  coord5  = new Point(400,300);
	  coord6  = new Point(300,300);
	  coord7  = new Point(300,400);
	  coord8  = new Point(200,400);
	  coord9  = new Point(200,300);
	  coord10 = new Point(100,300);
	  coord11 = new Point(100,200);
	  coord12 = new Point(200,200);
	  s.container = [coord1,coord2,coord3,coord4,coord5,coord6,
		    coord7,coord8,coord9,coord10,coord11,coord12],
//	  nodes.pop();

	  drawSpiral(s);
  }


                   ///////////////////////////////////
                   // test 21: DRAW PARAB
                   ///////////////////////////////////
      function test21 () {
	  coord1 = new Point(50,0);       coord11=new Point(300,10);
	  coord2 = new Point(50,400);     coord12=new Point(350,200);
	  coord3 = new Point(50,400);     coord13=new Point(500,100);
          coord4 = new Point(400,400);    coord14=new Point(400,400);
	  s = { color: "blue",
		numSteps: 20
	      };
	  thing = new StringThing(s);
	  let parab = [coord1,coord2,coord3,coord4];
	  drawParab(thing,parab);
    }
                   ///////////////////////////////////
                   // test 22: GET EQUATION OF A LINE
                   ///////////////////////////////////
    function test22(){
	  // Example usage:
	  const point1 = new Point(1,6);
	  const point2 = new Point(3,2);

	const equation = getLineEquation(point1, point2);
	printTitle("Test 22: Get equation of a line: " + equation);
      }

                   ///////////////////////////////////
                   // test 23: ROTATE A LINE
                   //          Actually, rotate a point
                   //          about a pivot
                   ///////////////////////////////////
    function test23() {
	printTitle("Test 23: rotate a line (actually rotate a point about a pivot)");
	  start = new Point(25,25);
	  end   = new Point(300,300);
	  angle = toRadians(20);
	  newPt = rotatePoint(start,end, angle);
	  drawLine(start,end,"green");
	  drawLine(start,newPt,"blue");
      }

                   ///////////////////////////////////
                   // test 24: PARAMETRIC
                   ///////////////////////////////////
	  function test24() {
// draw circle X,Y
	      let pts = range(0, 2*Math.PI, 100);

//	      printTitle("Test 24: 1--scale 400");
//	      let funcX = function(t) { return .1*Math.sin(t); };
//	      let funcY = function(t) { return .1*Math.cos(t); };
/********************************************************************/	      
	      pts = range(0,2*Math.PI, 3000);
//	      printTitle("Test 24: 2");   // scale .5
//	      a = 80;  b=1;   c=1;    d=80;  j=3;  k=3;

//	      printTitle("Test 24: 3");   // scale .5
//	      a = 80;  b=1;   c=80;   d=1;   j=3;  k=3;

//	      printTitle("Test 24: 4");   // scale .5
//	      a = 40;  b=99;  c=100;  d=40;  j=3;  k=4;

//	      printTitle("Test 24: 5");   // scale .5
//	      a = 40;  b=99;  c=100;  d=40;  j=4;  k=4;

//	      printTitle("Test 24: 6");   // scale .5
//	      a = 80;  b=99;  c=100;  d=40;  j=4;  k=4;

//	      printTitle("Test 24: 7");


//	      pts = range(0,2*Math.PI, 3000);
//	      a = 160;  b=99;  c=200;  d=40;  j=4;  k=4;
//	      funcX = function(t) { return 150*(Math.cos(a*t) - Math.cos(b*t)**j) ; } ;
//	      funcY = function(t) { return 150*(Math.sin(c*t) - Math.sin(d*t)**k) ; } ;

//	      printTitle("Test 24: 8");   // scale 20
//	      pts = range(0,2*Math.PI, 3000);
//	      funcY= function(t) {
//	           return 6*Math.sin(13.58*t*Math.round(Math.sqrt(Math.cos(Math.cos(7.4*t))))); } ;
//	      funcX = function(t) { return 6*Math.pow(Math.cos(13.58*t),4) * Math.sin(Math.sin(7.4*t)) ; } ;
//	      printTitle("Test 24: 9");   // scale 60
//	      funcX = function(t) { return Math.cos(5.9*t) + .25*Math.cos(5.75*t) + Math.cos(65*t) ; };
//	      funcY = function(t) { return Math.sin(5.9*t) + .25*Math.sin(5.75*t) + Math.sin(65*t) ; };
	      
//	      printTitle("Test 24: 10");   // scale 60
//	      funcX = function(t) { return Math.cos(t)+(1/3)*(Math.cos(123*t)+Math.sin(250*t)) ; };
//	      funcY = function(t) { return Math.sin(t)+(1/3)*(Math.sin(123*t)+Math.cos(245*t)) ; };

		 
//	      pts = range(0,2*Math.PI, 3000);
//	      printTitle("Test 24: 11");   // scale 60
//	      funcX = function(t) { return 1.4*Math.cos(t)+(1/3)*Math.sin(201*t) ; };
//	      funcY = function(t) { return 1.4*Math.sin(t)+(1/3)*Math.cos(201*t) ; };

//	      printTitle("Test 24: 12");   // scale 60
//	      funcY = function(t) { return 1.4*Math.sin(t)+(1/3)*Math.cos(193*t) ; };
	      
//	      printTitle("Test 24: 13");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t)+.5*Math.sin(199*t) ;}; // orig

//	      printTitle("Test 24: 14");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t)+.5*Math.sin(200*t) ;}; // orig

//	      printTitle("Test 24: 15");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t)+.5*Math.sin(198*t) ;};

//	      printTitle("Test 24: 16");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t)+.5*Math.sin(197*t) ;};

//	      printTitle("Test 24: 17");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t)+.5*Math.sin(196*t) ;};
//	      printTitle("Test 24: 18");   // scale 60
//	      funcY = function(t) { return 1.5*Math.sin(t)+.5*Math.cos(201*t) ;};
//	      funcY = function(t) { return 1.5*Math.sin(t)+.5*Math.cos(202*t) ;};

	      printTitle("Test 24: 19");   // scale 60
	      funcX = function(t) { return Math.cos(t) + (1/1.45)*Math.sin(195*t) ; };
	      funcY = function(t) { return Math.sin(t) + (1/1.45)*Math.cos(201*t) ; };

//	      printTitle("Test 24: 20");   // scale 60
//	      funcX = function(t) { return 1.5*Math.cos(t) + (1/3)*Math.sin(125*t) ; };
//	      funcY = function(t) { return 1.5*Math.sin(t) + (1/3)*Math.cos(251*t) ; };

//	      printTitle("Test 24: 21");   // scale 60
//	      funcX = function(t) { return Math.cos(t) + (1/1.4)*Math.cos(110*t) ; };
//	      funcY = function(t) { return Math.sin(t) + (1/1.4)*Math.cos(112*t) ; };
//	      printTitle("Test 24: 22");   // scale 60
//	      funcY = function(t) { return Math.sin(t) + (1/1.4)*Math.pow(Math.sin(112*t),4) ; }; 
//	      printTitle("Test 24: 23");   // scale 60
//	      funcY = function(t) { return Math.sin(t) + (1/1.4)*Math.pow(Math.sin(112*t),3) ; };//orig

	
//	      printTitle("Test 24: 24");   // scale 30
//	      funcX = function(t) { return 3*Math.cos(t)+Math.cos(3*t); };
//	      funcY = function(t) { return 3*Math.sin(t)-Math.sin(3*t); };


//	      pts = range(0,2*Math.PI, 500);
//	      pts = range(-2*Math.PI,2*Math.PI, 500);
//	      pts = range(0, 40, 5000);
//	      printTitle("Test 24: 25");   // scale 30
//	      funcX = function(t) { return Math.cos(t) +
//				    (1/3)*(Math.cos(123*t) + Math.sin(250*t)) };
//	      funcY = function(t) { return Math.sin(t) +
//				    (1/3)*(Math.sin(123*t) + Math.cos(245*t)) } ;

//	      printTitle("Test 24: 26");   // scale 30
//	      funcX = function(t) { return Math.cos(t) + 2*Math.sin(2*t) ; };
//	      funcY = function(t) { return 2*Math.cos(t) + Math.sin(t); };


//	      printTitle("Test 24: 27--Maybe someday figure out how to rotate");   // scale 30
//	      pts = range(-2*Math.PI,2*Math.PI, 500);
//	      funcX = function(t) { return 10*Math.sin(2.78*t) *
//				    Math.round(Math.sqrt(Math.cos(Math.cos(8.2*t)))) ;}
//				    
//	      funcY = function(t) { return 9*Math.cos(2.78*t)*Math.cos(2.78*t) *
//				    Math.sin(Math.sin(8.2*t)) ; }

//	      funcX = function(t) { return };
//	      funcY = function(t) { return };


//	      printTitle("Test 24: 27--an ellipse--IMPORTANT");   // scale 30
//	      pts = range(0,2*Math.PI, 500);
//	      funcX = function(t) { return 4*Math.cos(t) };
//	      funcY = function(t) { return 8*Math.sin(t) };
	      
//	      printTitle("Test 24: 28--right branch hyperbola");   // scale 30
//	      pts = range(-2*Math.PI,2*Math.PI, 300);
//	      funcX = function(t) { return 80*(1/Math.cos(t)); };
//	      funcY = function(t) { return 80*Math.tan(t) };

	      drawParametric(funcX,funcY, pts);
	  }


                   ///////////////////////////////////
                   // test 26: MORE POLYGONS
                   ///////////////////////////////////
///////////////////////////////////////////////
//// test 26
    function test26() {
	printTitle("Test 26");
	let s = { color: "green",
		  midpoint: new Point(110,110),
		  radius:   100,
		  numSteps: 40,
		  shorten: 15
		};
	thing = new StringThing(s);
	drawRegularPolygonTouch(thing);
	let nodes = createNodes(thing);
	s = { color: "green",
	      midpoint: new Point(100,110),
	      rotate: 90,
	      numSteps: 40,
	      radius:   100,
	      shorten: 15
	    };
	thing = new StringThing(s);
	drawRegularPolygonTouch(thing);
	s = { color: "blue",
	      midpoint: new Point(250,220),
//	      rotate: .001,
		  radius:   180,
		  numSteps: 40,
		  shorten: 15
		}; 
	thing = new StringThing(s);
	drawRegularStar(thing);
	context.fillStyle = "blue";
	createPrintNodes(thing);
    }


                   ///////////////////////////////////
                   // test 27: RADIAL PARAMETRICS
                   ///////////////////////////////////
	  function test27() {
	      let pts = range(0, 2*Math.PI, 100);

	      pts = range(-30,30,600);
//	      printTitle("Test 27-1: Print Radial");
//	      funcY = function(t) { return 0.4*Math.sin(t/1.2);};

//	      printTitle("Test 27-2: Print Radial");    // scale 150
//	      funcY = function(t) { return Math.cos((1/6)*t);};	      

//	      printTitle("Test 27-3: Print Radial");   //scale=200
//	      funcY = function(t) { return Math.cos((1/4)*t);};	      

//	      printTitle("Test 27-4: Print Radial");  
//	      funcY = function(t) { return Math.cos((1/7)*t);};

//	      printTitle("Test 27-5: Print Radial");
//	      funcY = function(t) { return Math.cos((2/7)*t);};	      

//	      printTitle("Test 27-6 Print Radial");
//	      funcY = function(t) { return Math.cos((8/7)*t);};

//	      printTitle("Test 27-7: Print Radial");
//	      funcY = function(t) { return Math.cos((5/6)*t);};	      	

//	      printTitle("Test 27-8: Print Radial");
//	      funcY = function(t) { return Math.cos((6/7)*t);};	      

//	      printTitle("Test 27-9: Print Radial");
//	      funcY = function(t) { return Math.cos((7/6)*t);};	      

//	      printTitle("Test 27-10: Print Radial");
//	      funcY = function(t) { return Math.cos((8/5)*t);};	      

//	      printTitle("Test 27-11: Print Radial");
//	      funcY = function(t) { return Math.cos((10/7)*t);};	      

//	      printTitle("Test 27-12: Print Radial");
//	      funcY = function(t) { return Math.cos((12/7)*t);};	      

//	      printTitle("Test 27-13: Print Radial");
//	      funcY = function(t) { return Math.cos((6/15)*t);};	      
//	      pts = range(0, 200, 1000); 
//	      printTitle("Test 27-14: Print Radial");
//	      funcY = function(t) { return 3*Math.sin(t) + 2; }  // scale 40
//	      printTitle("Test 27-15: Print Radial");
//	      funcY = function(t) { return 3*Math.sin((Math.PI*t)) }

//	      printTitle("Test 27-16: Print Radial");
//	      pts = range(0, 100, 1000); 
//	      funcY = function(t) { return .1*t ; } 
//	      funcX = function(t) { return .3*t ; }

//	      printTitle("Test 27-16: Print Radial");
//	      pts = range(0, 100, 1000); 
//	      funcY = function(t) { return .1*t ; } 
//	      funcX = function(t) { return .3*t ; }

	      printTitle("Test 27-17: Print Radial");
	      pts = range(-2*Math.PI, 2*Math.PI, 200); 
	      funcY = function(t) { return Math.sqrt(4*Math.cos(2*t)) ; } 
	      funcX = function(t) { return t ; }
	      drawPolar(funcX,funcY,pts);
	      
	  }

                   ///////////////////////////////////
                   // test 28A: 
                   ///////////////////////////////////
    function test28a() {
	printTitle("Figure 28a");
	const amplitude = 30; // Height of the wave
	const frequency = 0.03; // How many cycles fit in the width
	const centerY = 300;
	
	beginPath();
	moveTo(30, centerY+18); // Start at the left edge, centered vertically

	for (let x = 30; x < 700; x++) {
	    // Calculate y-coordinate using the sine function
	    // Math.sin takes radians, so frequency * x adjusts the input
	    const y = amplitude * Math.cos(frequency * x) + centerY;
	    lineTo(x, y);
	}

	context.strokeStyle = 'blue'; // Color of the wave
	context.lineWidth = 2; // Thickness of the line
	stroke();
    }

                   ///////////////////////////////////
                   // test 28:
                   ///////////////////////////////////
    function test28(){
	printTitle("Test 28");
	context.lineWidth=1;
	for (let x = 0; x < 1000; x++) {
	    X = toRadians(x);
	    let y = 200 + 30 * Math.cos(toRadians(x));
	    drawCircle(new Point(X*40,y), 1, "blue");
	    //	    if ((x % 10) == 0) testCircle(new Point(X*40,y));
	    let p90 = toRadians(90);
	    let p180 = toRadians(180);
	    let p270 = toRadians(270);
	    let p360 = toRadians(360);
	    context.strokeStyle = "black";
	    context.fillStyle = "black";
	    if ((x % 90) == 0) printCircNum(new Point(X*40,y),90);
	}
    }

                   ///////////////////////////////////
                   // test 29: CHORDS
                   ///////////////////////////////////
    function test29() {
	printTitle("Test 29: Chords");
	radius = 200;
	center = new Point(300,300);
	s = { midpoint: center,
	      numNodes:   50,
	      yScale:     1.4,
	      skip:       10,
	      startSkip:  -10,
	      endSkip:    0,
	      withinCirc: START_END,
	      color:      "blue",
	      radius:     radius
	    };
	thing = new StringThing(s);
	drawInCircle(thing);
      }    

                   ///////////////////////////////////
                   // test 30: SIMPLE SPIRAL
                   ///////////////////////////////////
    function test30(){
	printTitle("Test 30: Simple Spiral");
	s = { radius:    5,                    // this is a start radius
	      midpoint:  new Point(200,300),
	      color:     blue
	    }
	let angle = 0;
	let spread = 6;                        // how fast spira expands
	let maxAngle = Math.PI*10;             // 5 full turns
	thing = new StringThing(s);
	drawPureSpiral(thing,angle,spread,maxAngle);
    }

                   //////////////////////////////////////
                   // test 31:  SIMPLE SPIRAL, TAKE 2
                   //           using a simple fill style
                   //////////////////////////////////////
    function test31() {
	printTitle("Test 31: Simple Spiral, take 2, also using a fill style");
   	let s = { radius:    5,                    // this is a start radius
	      midpoint:  new Point(200,300),
	      color:     blue
	    }	
 	let thing = new StringThing(s);
	let gap = 6;
	let numRotations = 8;
	drawPureSpiralA(thing,gap,numRotations);
    }

                   ///////////////////////////////////
                   // test 32: SIMPLE SPIRAL
                   //          take 3--drawing circles
                   //          not integrated
                   ///////////////////////////////////
    function test32() {
	printTitle("Test 32: Simple Spiral, take 3--drawing circles Not Integrated");
   	let s = { radius:    5,                    // this is a start radius
	      midpoint:  new Point(200,300),
	      color:     blue
	    }	
 	let thing = new StringThing(s);
	let gap = 6;
	let ptsToDraw = 200;
	drawPureSpiralB(thing,ptsToDraw);
    }

                   ///////////////////////////////////
                   // test 33:  FERMAT SPIRAL
                   //           not integrated
                   ///////////////////////////////////
    function test33() {
	printTitle("Test 33: Fermat Spiral");
   	let s = { midpoint:  new Point(300,300),
		  color:     blue
		}	
 	let thing = new StringThing(s);
	let scaleFactor = 30;
	let numTurns = 6;
	let gap = 1.2;
	drawFermatSpiral(thing,scaleFactor,numTurns, gap);
    }
    
                   ///////////////////////////////////
                   // test 34: LOG SPIRAL 
                   //          not integrated
                   ///////////////////////////////////
    function test34() {
	printTitle("Test 34: log Spiral--not integrated");
   	let s = { midpoint:  new Point(300,300),
		  color:     blue
		}	
 	let thing = new StringThing(s);
	let a = 15;
	let b = .08;
	startAngle = 0;
	endAngle   = Math.PI*10;
	step       = .1;
	drawLogarithmicSpiral(thing, a, b, startAngle, endAngle, step)
    }

                   ///////////////////////////////////
                   // test 35: EULER SPIRAL
                   //          not integrated
                   ///////////////////////////////////
    function test35() {
	printTitle("Test 35: euler Spiral--not integrated");
   	let s = { midpoint:  new Point(350,150),
		  color:     blue
		}	
 	let thing = new StringThing(s);
	let totalLength = 3000;
	let numSegments = 10000;
	let scaleFactor = 15;
	drawEulerSpiral(thing, totalLength, numSegments, scaleFactor);
    }    


                   ///////////////////////////////////
                   // test 36: SPIRAL OF THEODORUS
                   //          not integrated
                   ///////////////////////////////////
   function test36() {
       printTitle("Test 36: Spiral of Theodorus--not integrated");
       let s = { midpoint:  new Point(300,260),
		 color:     blue
	       }	
       let thing = new StringThing(s);
       numTriangles = 23;
       drawTheodorusSpiral(thing,numTriangles);
    }        

                   ///////////////////////////////////
                   // test 37: DRAW CHORDS VARIATION
                   ///////////////////////////////////
    function test37() {
	printTitle("Test 37: Draw Chords Variation");
	s = { midpoint:  new Point(400,400),
	      color:     "saddlebrown",
	      ellipse:   {a: 200,
			  b: 350
		 	 },
	      numNodes:  120,
	      rotate:    90,
	      startSkip: 0,
              endSkip:   0,
	      skip:      20,
	      taper:     true
	    };
	let thing = new StringThing(s);
        drawInEllipse(thing);

	
    }

                   ///////////////////////////////////
                   // test 38: 
                   ///////////////////////////////////
    function test38(){
	printTitle("Test 38");
	radius = 200;
	center = new Point(200,250);
	s = { midpoint: center,
	      numNodes:     70,
	      skip:         16,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   TAPER,
	      color:        "blue",
	      radius:       radius };
	thing = new StringThing(s);
	drawInCircle(thing);
    }

                   ///////////////////////////////////
                   // test 39:
                   ///////////////////////////////////
    function test39(){
	printTitle("Test 39: Playing wth circles");
	function drawCirc(thing) {
	    drawCircle(thing.midpoint,thing.radius, thing.color);
	}
	function drawPartial(nodes,start,end,color) {
	    for (let i=start; i<end; i++) {
		j = i+1;
		drawLine(nodes[i],nodes[j],thing.color);
	    }
	}
	
	s={color:    blue,
	   radius:   100,
	   numNodes: 32,
	   rotate:   90,
	   midpoint: new Point(300,200)
	  };
	thing      = new StringThing(s);
	let nodesUpper = createNodes(thing);
	let start      = nodesUpper.length/2
	let end        = nodesUpper.length;
	nodesUpper = nodesUpper.concat(nodesUpper[0]);
	drawPartial(nodesUpper,start,end,thing.color);
	nodesUpper.length = nodesUpper.length -1;
	nodesUpper = nodesUpper.slice(nodesUpper.length/2);

	thing.midpoint = new Point(300,400);
	nodesLower     = createNodes(thing);
	start          = 0;
	end            = nodesLower.length/2;
	drawPartial(nodesLower,start,end,thing.color);
	nodesLower.length = nodesLower.length/2;

	s={color:    blue,
	       radius:   200,
	       numNodes: 64,
	       midpoint: new Point(300,300)
	      };
	let thingBig = new StringThing(s);
	nodesBig = createNodes(thingBig);
	
	let numNodes = thingBig.numNodes;
	nodesTopLeft     = nodesBig.slice(numNodes/4,  numNodes/2);
	nodesBottomLeft  = nodesBig.slice(numNodes/2,  3*numNodes/4);
	nodesBottomRight = nodesBig.slice(3*numNodes/4,numNodes);
	nodesTopRight    = nodesBig.slice(0,           numNodes/4);


	thingBig.arm1 = nodesUpper;
	thingBig.arm2 = nodesTopLeft;
	stitcher(thingBig);
	
	thingBig.arm1 = nodesLower;
	thingBig.arm2 = nodesBottomRight;
	stitcher(thingBig);

	drawCircle(thingBig.midpoint,thingBig.radius,thingBig.color);
    }

    function test40() {
	function toColor(color,percent) {
	    let num = Math.round((percent/100)*255).toString(16);
	    return (color+num);
	}
	printTitle("Test 40: Shading");
//	showColors("blue",500);

        color = "#6b6bff";
	context.fillStyle = color;
	context.fillRect(10,200,400,400);

	color = "#9e9eff"
	context.fillStyle = toColor(color,40);
	context.fillRect(60,100,75,600);

	context.fillStyle = toColor(color,60);
	context.fillRect(135,100,75,600);


   	context.fillStyle = toColor(color,80);
	context.fillRect(210,100,75,600);
  
  	context.fillStyle = toColor(color,100);;
	context.fillRect(285,100,75,600);

    }


    function test41() {
	printTitle("Test 41: ptsOnArc");
	pt1 = new Point(100,150);
	pt2 = new Point(400,200);
	const radius = 180;
	pts = ptsOnArc(pt1, pt2, radius, 20);
	for (i=0;i<pts.length;i++)
	    setPt(pts[i]);
	pt1 = new Point(100,200);
	pt2 = new Point(400,250);
	pts = ptsOnArc(pt2, pt1, radius, 20);
	for (i=0;i<pts.length;i++)
	    setPt(pts[i]);
    }
   
    function test42() {
	printTitle("Text 42: arcCurvature Points");
	pt1 = new Point(50,50);
	pt2 = new Point(350,50);
	curvature = -4;
	numPoints = 20;
	let pts = arcCurvature(pt1, pt2, curvature, numPoints);
	for (i=0;i<pts.length;i++)
	    setPt(pts[i]);
	drawLine(pt1,pt2);
    }


/////////////////////////////////////////////////////////////////
// Figures
/////////////////////////////////////////////////////////////////
///////////////////////////////////////////////
                   ////////////////////////////////////
                   // Figure 1: DRAWING MANY PARABOLAS
                   ////////////////////////////////////
    function figure23(){
	printTitle("Figure23: Drawing many parabolas");
	s = { color: "cornflowerblue",
	      midpoint: new Point(300,350),
	      xScale: 1.3,
	      yScale: 1.5,
	      radius: 300,
	      rotate: 45,
	      numSteps: 30
	    }
	thing = new StringThing(s);
	drawRegularPolygon(thing);
	s = { color: "burlywood",
	      midpoint: new Point(300,350),
 	      xScale: 1,
	      yScale: 1.158,
	      radius: 275
	    };
	thing = new StringThing(s);
	drawRegularStar(thing);
  	coord1 = new Point(24,32);
	coord2 = new Point(24,200);
	coord3 = new Point(24,470);
	coord4 = new Point(24,668);
	coord5 = new Point(576,668);
	coord6 = new Point(576,470);
	coord7 = new Point(576,200);
	coord8 = new Point(576,32);
	mid =    thing.midpoint;
	s = { color: "lightgreen" };
	thing = new StringThing(s);
	parabs = [[coord1,mid,coord3],
		  [coord3,mid,coord5],
		  [coord5,mid,coord7],
		  [coord7,mid,coord1]];
	drawParabs(thing,parabs);
	s = { color: "palevioletred" };
	thing = new StringThing(s);
	parabs = [[coord2,mid,coord4],
		  [coord4,mid,coord6],
		  [coord6,mid,coord8],
		  [coord8,mid,coord2]];
	drawParabs(thing,parabs);

  }
	

                   ///////////////////////////////////
                   // Figure 36: REGULAR STAR
                   ///////////////////////////////////
      function figure036(thing) {
  	  let nodes = createNodes(thing);	
	  const lineEnd = [];
	  let deltaX, deltaY,newX,newY;
	  for (let i=0;i<thing.numNodes;i++){
	      deltaX=thing.midpoint.x - nodes[i].x;
	      deltaY=thing.midpoint.y - nodes[i].y;
	      newX = thing.midpoint.x - thing.factor*deltaX;
	      newY = thing.midpoint.y - thing.factor*deltaY;
	      lineEnd[i] = new Point(newX,newY);
	  }
	  parabs = [];
	  for (i=0;i<thing.numNodes;i++) {
	      if (i==thing.numNodes-1) j=0; else j = i+1;
	      parabs.push([nodes[i],lineEnd[i],lineEnd[j],nodes[j]]);
	  }
	  drawParabs(thing,parabs);


	  // DRAW RED
//	  parabs = [];
//	  thing.newColor = "red";
//	  thing.newNodes = 12;
//	  nodes = createNodes(thing);
//          for (i=0;i<nodes.length;i++) {
//	      if (i==7) j=0; else j = i+1;
//	      center = getP3(nodes[i],nodes[j],.82);
//	      parab = [nodes[i],center,nodes[j]];
//	      parabs.push(parab);
//	  }
//	  drawParabs(thing,parabs);

//	  s ={ numNodes: 8,
//	       numSteps: 12,
//	       midpoint: new Point(300,300),
//	       radius: 75,
//	       color: "gray" };
//	  thing = new StringThing(s);
//	  drawRegularStar(thing);

      }

                   /////////////////////////////////////
                   // Figure 60: PARABOLAS WITHIN CIRCLE
                   /////////////////////////////////////
    function figure60() {
	printTitle("Figure 60: Parabolas within a circle");
	s = { color: "red",
	      both: true,
	      lineWidth: .5,
	      midpoint: new Point(300,300),
	      numNodes: 4,
	      numSteps: 20
	    };
	let thing = new StringThing(s);
	drawRegularStar(thing);
//	drawCircle(new Point(300,300),200,"red");
	drawCircularParabola(thing);
    }

    function figure72(){
	//        background("darkblue");
//	showColors("lightskyblue",300);
	drawSpeckledRadialGradient(context, theCanvas.width, theCanvas.height, {
            dotRadius: 1,
            totalDots: 30000,
            noiseOpacity: 0.4,
            falloffPower: 2
	});

	function buildParab(s,thing) {
	    thing.color = s.color;
	    let x = s.center.x;
	    let y = s.center.y;
	    if (s.direction == DL) {
		pt1 = new Point(x-s.length,y);
		pt2 = new Point(x,         y+s.length);
	    } else if (s.direction == UL) {
		pt2 = new Point(x-s.length,y);
		pt1 = new Point(x,         y-s.length);
	    } else if (s.direction == UR) {
		pt1 = new Point(x+s.length,y);
		pt2 = new Point(x,         y-s.length);
	    } else {             // DR
		pt1 = new Point(x+s.length,y);
		pt2 = new Point(x,         y+s.length);
	    }
	    drawParab(thing,[pt1, s.center, pt2]);
	    
	}
    
	const UL = 0;
	const DL = 1;
	const UR = 2;
	const DR = 3;
//	const colorBrown = "#f2e9d3";
	const colorBrown = "#f8f8e8";
	//	const colorBlue  = "#8585c7";
	const colorBlue = "#71add2";
	printTitle("Figure 72",new Point(250,20),color="white");
	let length = 160;
	let xCenter = 280;
	let yCenter = 300;
	let s = { numSteps:  18 };
	let thing = new StringThing(s);
	// 0
	let pt = new Point(xCenter - 1.6*length, yCenter - 1.45*length);
	setPt(pt,false);  
	s = {center: pt, direction: DR, length: length, color: colorBlue };
	buildParab(s,thing);

	// 1
	pt = new Point(xCenter - 1.4*length,yCenter);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBlue };
	buildParab(s,thing);
	
	// 2
	pt = new Point(xCenter - 1.15*length, yCenter - 1.7*length);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 3
	pt = new Point(xCenter - 1.0*length, yCenter -.25*length);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 4
	pt = new Point(xCenter -  .6*length, yCenter - 1.3*length);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 5
	pt = new Point(xCenter - .25*length, yCenter);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 6
	pt = new Point(xCenter -  .15*length, yCenter -  1.55*length);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBrown };
	buildParab(s,thing);

	// 7
	pt = new Point(xCenter + 1.6*length, yCenter - 1.45*length);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBlue };
	buildParab(s,thing);
	
	// 8
	pt = new Point(xCenter + 1.4*length,yCenter);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBlue };
	buildParab(s,thing);
	
	// 9
	pt = new Point(xCenter + 1.15*length, yCenter - 1.7*length);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBrown };
	buildParab(s,thing);
	
	// 10
	pt = new Point(xCenter + 1.0*length, yCenter -.25*length);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBrown };
	buildParab(s,thing);
	
	// 11
	pt = new Point(xCenter +  .6*length, yCenter - 1.3*length);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBlue };
	buildParab(s,thing);
	
	// 12
	pt = new Point(xCenter + .25*length, yCenter);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBlue };
	buildParab(s,thing);
	
	// 13
	pt = new Point(xCenter +  .15*length, yCenter -  1.55*length);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 14
	pt = new Point(xCenter + 1.6*length, yCenter + 1.45*length);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 15
	pt = new Point(xCenter + 1.4*length,yCenter);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 16
	pt = new Point(xCenter + 1.15*length, yCenter + 1.7*length);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBrown };
	buildParab(s,thing);
	
	// 17
	pt = new Point(xCenter + 1.0*length, yCenter +.25*length);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBrown };
	buildParab(s,thing);

	// 18
	pt = new Point(xCenter +  .6*length, yCenter + 1.3*length);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBlue };
	buildParab(s,thing);

	// 19
	pt = new Point(xCenter + .25*length, yCenter);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBlue };
	buildParab(s,thing);

	// 20
	pt = new Point(xCenter +  .15*length, yCenter +  1.55*length);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 21
	pt = new Point(xCenter - 1.6*length, yCenter + 1.45*length);
	setPt(pt,false);  
	s = {center: pt, direction: UR, length: length, color: colorBlue };
	buildParab(s,thing);

	// 22
	pt = new Point(xCenter - 1.4*length,yCenter);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBlue };
	buildParab(s,thing);

	// 23
	pt = new Point(xCenter - 1.15*length, yCenter + 1.7*length);
	setPt(pt,false);
	s = {center: pt, direction: UR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 24
	pt = new Point(xCenter - 1.0*length, yCenter + .25*length);
	setPt(pt,false);
	s = {center: pt, direction: DR, length: length, color: colorBrown };
	buildParab(s,thing);

	// 25
	pt = new Point(xCenter -  .6*length, yCenter + 1.3*length);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 26
	pt = new Point(xCenter - .25*length, yCenter);
	setPt(pt,false);
	s = {center: pt, direction: DL, length: length, color: colorBlue };
	buildParab(s,thing);

	// 27
	pt = new Point(xCenter -  .15*length, yCenter +  1.55*length);
	setPt(pt,false);
	s = {center: pt, direction: UL, length: length, color: colorBrown };
	buildParab(s,thing);





	s = {color: "#f2e9d3",
		 radius:    length,
		 midpoint:  new Point(xCenter,yCenter),
		 numNodes:  4,
		 numSteps:  18
		};
	thing = new StringThing(s);
	drawRegularStar(thing);
//	parabs = [ [ new Point(xlevel3,ylevel1),
//		     new Point(
//		   ]
//		 ];
//	parabs = [];
//	parabs = buildParab(direct,length);
//	thing.color = "blue";
//	drawParabs(thing,parabs);
	
    }
   

                   ///////////////////////////////////
                   // Figure 81: MORE PARABOLAS
                   ///////////////////////////////////
///////////////////////////////////////////////
//// Figure 81
    function figure81() {
	printTitle("Figure 81: Yet more parabolas--First I'm building");

	pts = [ new Point(190,250),
		new Point(140,80),						       
		new Point(180,555),
		new Point(450,100),
		new Point(450,600)
	      ];	    
	crossHair(pts,"black");

	drawLine(new Point(0,47),new Point(800,47),"black",2);
	drawLine(new Point(16,3),new Point(16,800),"black",2);
	gl.dot = true;
	    
	let s = { color: "green",
		  midpoint: new Point(320,350),
		  radius:   300,
		  numSteps: 40,
		  shorten: 15
		};
	thing = new StringThing(s);
	drawRegularPolygonTouch(thing);
	let nodes = createNodes(thing);
	s = { color: "green",
	      midpoint: new Point(320,350),
	      rotate: 90,
	      numSteps: 40,
	      radius:   300,
	      shorten: 15
	    };
	thing = new StringThing(s);
	drawRegularPolygonTouch(thing);
	s = { color:      "goldenrod",
	      midpoint: new Point(320,350),
	      radius:     130,
	      rotate:     0,
	      numSteps:   12,
	      shorten:    0
	    };
	thing1 = new StringThing(s);
	drawRegularStar(thing1);
	let nodes1   = createNodes(thing1);
	thing1.trunc = 12;
	for (i=0; i < 4; i++){
	    j=i+1;
	    if (i==3) j = 0;
	    thing1.arm1  = ptsOnLine(thing.numSteps, nodes[i], nodes[j]);
	    thing1.arm2  = ptsOnLine(thing1.numSteps,nodes1[j],thing1.midpoint);
	    stitcher(thing1);
	}
    }

                   ////////////////////////////////////
                   // Figure 82: COMPLICATED PARABOLAS
                   //            USING MIDPOINTS
                   ////////////////////////////////////
    function figure82() {
        printTitle("Figure82: complicated parabolas. Using line midpoints");
	s = { mid: true,
	      radius: 250,
	      rotate: 45,
	      midpoint: new Point(300,300)
	    };
	let thing = new StringThing(s);
	context.fillStyle = "blue";
	context.lineWidth = 2;
	createPrintNodes(thing);
	printText(" ");
	printText("Inner Box");
	s = { mid:    true,
	      color:  "blue",
	      radius: 125,
	      rotate: 45,
	      xScale: .7,
	      numSteps: 12,
	      midpoint: new Point(300,300)
	    };
	thing = new StringThing(s);
	context.fillStyle = "green";
	createPrintNodes(thing);
	parabs = [];
	parab = [ _m(gl.pts[4], gl.pts[9]), gl.pts[0], _m(gl.pts[7],gl.pts[9])];  // 0
	parabs.push(parab);
	parab = [ gl.pts[8], gl.pts[4],gl.pts[9]];                                // 4
	parabs.push(parab);
	parab = [ _m(gl.pts[4],gl.pts[8]), gl.pts[1], _m(gl.pts[5],gl.pts[8])];   // 1
	parabs.push(parab);	thing.xScale=1;
	parab = [ gl.pts[8], gl.pts[5], gl.pts[11]];                              // 5
	parabs.push(parab);
	parab = [ _m(gl.pts[5],gl.pts[11]), gl.pts[2], _m(gl.pts[6],gl.pts[11])]; // 2
	parabs.push(parab);
	parab = [ gl.pts[10], gl.pts[6], gl.pts[11]];                             // 6
	parabs.push(parab);
	parab = [ _m(gl.pts[6],gl.pts[10]), gl.pts[3], _m(gl.pts[7],gl.pts[10])]; // 3
	parabs.push(parab);
	parab = [ gl.pts[10], gl.pts[7], gl.pts[9]];                              // 7
	parabs.push(parab);
	pt =  _m(gl.pts[4],gl.pts[9]);
        parab = [gl.pts[4], pt, _m(gl.pts[0],pt)];                                // 0-4
	parabs.push(parab);  
	thing.xScale=1;
	thing.newColor = "sandybrown";
	drawParabs(thing,parabs);
	r = {midpoint: new Point(300,300),
             start:    _m(gl.pts[4],gl.pts[9]),
	     color:    "sandybrown",
             end:      gl.pts[9],
	     numSteps: 8
	    };
	thing = new StringThing(r);
	drawRadiate(thing);
    }

                   ///////////////////////////////////
                   // Figure 83: TWO SETS OF 3s
                   //            Do more here
                   ///////////////////////////////////
    function figure83() {
	printTitle("Figure 83: Two Sets of 3s: Do more here");
	s = { mid: true,
	      radius: 250,
	      rotate: 45,
	      xScale: 1,
	      numSteps: 19,
	      color: blue,
	      midpoint: new Point(250,300)
	    };
	let thing = new StringThing(s);
	context.fillStyle = "red";
	createPrintNodes(thing);
	context.fillStyle = "green";
	parabs = [];
	lPt = _m(gl.pts[0],gl.pts[6]);
	rPt = _m(gl.pts[1],gl.pts[6]);
        parab = [gl.pts[0],  lPt, gl.pts[4]];
	parabs.push(parab);
	parab = [lPt,gl.pts[4],rPt];
	parabs.push(parab);
        parab = [gl.pts[1],  rPt, gl.pts[4]];
	parabs.push(parab);
        parab = [gl.pts[1],  rPt, gl.pts[2]];
	parabs.push(parab);
	parab = [gl.pts[2],  rPt, gl.pts[6]];
	parabs.push(parab);
	parab = [rPt, gl.pts[6], lPt];
	parabs.push(parab);
	parab = [gl.pts[3],  lPt, gl.pts[6]];
	parabs.push(parab);
	parab = [gl.pts[3],  lPt, gl.pts[0]];
	parabs.push(parab);
	drawParabs(thing,parabs);
    }

                   ///////////////////////////////////
                   // Figure 84:
                   ///////////////////////////////////
    function figure84() {
	printTitle("Figure 84: Mutiple Start. Perhaps build");
	xDist = 80;
	yDist = 100;
	xLength = 100;
	yLength = 100;
        x1 = 50;
	x2 = x1+xLength;
	x3 = x2 + xDist/2;
	x4 = x3 + xDist/2;
	x5 = x4+xLength;
	y1 = 50;
	y2 = y1 + yLength;
	y3 = y2 + yDist/2;
	y4 = y3 + yDist/2;
	y5 = y4 + yLength;
	y6 = y5 + yDist/2;
	y7 = y6 + yDist/2;
	y8 = y7 + yLength;
	y9 = y8 + yDist/2;
	y10 = y9 + yDist/2;
	y11 = y10 + yLength;
	gl.pts[1] = new Point(x1,y3);
	gl.pts[2] = new Point(x1,y6);
	gl.pts[3] = new Point(x1,y9);
	gl.pts[4] = new Point(x2,y3);
	gl.pts[5] = new Point(x2,y6);
	gl.pts[6] = new Point(x2,y9);
	gl.pts[7] = new Point(x3,y1);
	gl.pts[8] = new Point(x3,y2);
	gl.pts[9] = new Point(x3,y4);
	gl.pts[10] = new Point(x3,y5);
	gl.pts[11] = new Point(x3,y7);
	gl.pts[12] = new Point(x3,y8);
	gl.pts[13] = new Point(x3,y10);
	gl.pts[14] = new Point(x3,y11);
	gl.pts[15] = new Point(x4,y3);
	gl.pts[16] = new Point(x4,y6);
	gl.pts[17] = new Point(x4,y9);
	gl.pts[18] = new Point(x5,y3);
	gl.pts[19] = new Point(x5,y6);
	gl.pts[20] = new Point(x5,y9);
	gl.ctr++;
	drawLine(gl.pts[1],gl.pts[4],"blue");
	drawLine(gl.pts[2],gl.pts[5],"blue");
	drawLine(gl.pts[3],gl.pts[6],"blue");
	drawLine(gl.pts[7],gl.pts[8],"blue");
	drawLine(gl.pts[9],gl.pts[10],"blue");
	drawLine(gl.pts[11],gl.pts[12],"blue");
	drawLine(gl.pts[13],gl.pts[14],"blue");
	drawLine(gl.pts[15],gl.pts[18],"blue");
	drawLine(gl.pts[16],gl.pts[19],"blue");
	drawLine(gl.pts[17],gl.pts[20],"blue");	
	context.fillStyle = "blue";
	for (i=1;i<gl.pts.length;i++) {
	    printCircNum(gl.pts[i]);
	}
	s = { color: blue,
//	      color: "cornflowerblue",
	      numSteps: 18,
	      lineWidth: .8,
//	      shorten:   80,
	      midpoint: _m(gl.pts[4],gl.pts[15])
//	      yIncrement: .8
	    };
	thing = new StringThing(s);
//	drawRegularStar(thing);
	parab = [gl.pts[1], gl.pts[4], gl.pts[8], gl.pts[7]];
	drawParab(thing,parab);
	parab = [gl.pts[1], gl.pts[4], gl.pts[9], gl.pts[10]];
	drawParab(thing,parab);
	parab = [gl.pts[18], gl.pts[15], gl.pts[9], gl.pts[10]];
	drawParab(thing,parab);
	parab = [gl.pts[15], gl.pts[18], gl.pts[7], gl.pts[8]];
	drawParab(thing,parab);
	parab = [gl.pts[9], gl.pts[10], gl.pts[5], gl.pts[2]];
	drawParab(thing,parab);
	parab = [gl.pts[2], gl.pts[5], gl.pts[11], gl.pts[12]];
	drawParab(thing,parab);
	parab = [gl.pts[6], gl.pts[3], gl.pts[11], gl.pts[12]];
	drawParab(thing,parab);
	parab = [gl.pts[3], gl.pts[6], gl.pts[13], gl.pts[14]];
	drawParab(thing,parab);
	parab = [gl.pts[14], gl.pts[13], gl.pts[17], gl.pts[20]];
	drawParab(thing,parab);
	parab = [gl.pts[20], gl.pts[17], gl.pts[12], gl.pts[11]];
	drawParab(thing,parab);
	parab = [gl.pts[12], gl.pts[11], gl.pts[16], gl.pts[19]];
	drawParab(thing,parab);
	parab = [gl.pts[19], gl.pts[16], gl.pts[10], gl.pts[9]];
	drawParab(thing,parab);
	parab = [gl.pts[7], gl.pts[8], gl.pts[5], gl.pts[2]];
	drawParab(thing,parab);
	parab = [gl.pts[7], gl.pts[8], gl.pts[16], gl.pts[19]];
	drawParab(thing,parab);
	parab = [gl.pts[2], gl.pts[5], gl.pts[13], gl.pts[14]];
	drawParab(thing,parab);
	parab = [gl.pts[14], gl.pts[13], gl.pts[16], gl.pts[19]];
	drawParab(thing,parab);
    }

                   ///////////////////////////////////////////
                   // Figure 85: ROUNDED USING COLOR GRADIENT
                   ///////////////////////////////////////////
    function figure85() {
	printTitle("Figure 85: Rounded, using color gradient");
	const gradient = context.createRadialGradient(350, 350, 30, 340, 240, 200);

// Add three color stops
	gradient.addColorStop(0, "white");
	color = calculateTintAndShade(colourNameToHex("red"),.9).tint.hex;
	gradient.addColorStop(.4, color);
	color = calculateTintAndShade(colourNameToHex("red"),.8).tint.hex;
	gradient.addColorStop(.8, color);
	color = calculateTintAndShade(colourNameToHex("red"),.7).tint.hex;
	gradient.addColorStop(.9, color);
	color = calculateTintAndShade(colourNameToHex("red"),.6).tint.hex;
	gradient.addColorStop(1, color);
	context.fillStyle = gradient;
	context.scale(1,1.455);
	context.fillRect(120, 15, 465, 465);
	context.resetTransform();

// Set the fill style and draw a rectangle

	color = calculateTintAndShade(colourNameToHex("red"),.3).shade.hex;

	s = { color: color,
	      numNodes: 6,
	      numSteps: 30,
	      rotate: 90,
	      midpoint: new Point(350,350),
	      yScale: 1.5,
	      both: true
	    };
	thing = new StringThing(s);
	drawCircularParabola(thing);
//	thing.newColor  = "blue";
	drawRegularStar(thing);
	beginPath();
	context.strokeStyle = "black";
	context.lineWidth = 4;
	x0=350;   // x coordinate of the starting circle
	y0=350;
	r0=60;    // radius of the starting circle
	x1=340;   // x coordinate of the ending circle
	y1=460;
	r1=130;   // radius of the ending circle
//	grd = createRadialGradient(x0,y0,r0,x1,y1,r1);
//	grd.addColorStop(0,"white");
//	grd.addColorStop(1,"blue");
//	context.fillStyle=grd;
	context.rect(120,20,465,675);

	stroke();
    }


                   ///////////////////////////////////
                   // Figure 98:
                   ///////////////////////////////////
    function figure98() {
	printTitle("Figure 098");
	gl.final = false;
	s = { startSkip: 4,
	      endSkip: 4,
	      radius: 350,
	      color: blue,
	      lineWidth: .3,
	      midpoint: new Point(325,435)
	    };
	thing = new StringThing(s);
//	drawRegularPolygon(thing);
//	let distance = 175;
	let distance = 165;
	let degrees  = 45;
	context.fillStyle="black";
	
	gl.pts[0] = new Point(20,350);
 	printCircNum(0,0);
	let temp      = new Point(320,350);
	gl.pts[1] = rotatePoint(gl.pts[0],temp,toRadians(-degrees));
	drawLine(0,1);
	printCircNum(1,1);

	gl.pts[2] = new Point(gl.pts[1].x+distance,gl.pts[1].y);
	printCircNum(2,2);
	temp      = new Point(gl.pts[2].x+300,gl.pts[2].y);
	gl.pts[3] = rotatePoint(gl.pts[2],temp,toRadians(degrees));
	printCircNum(3,3);
	drawLine(2,3);

	gl.pts[4] = new Point(gl.pts[0].x,gl.pts[0].y+distance);
	printCircNum(4,4);
	temp      = new Point(gl.pts[4].x+300,gl.pts[4].y);
	gl.pts[5] = rotatePoint(gl.pts[4],temp,toRadians(degrees));
	printCircNum(5,5);
	drawLine(4,5);	

    	gl.pts[6] = new Point(gl.pts[5].x+distance,gl.pts[5].y);
	printCircNum(6,6);
	temp      = new Point(gl.pts[6].x+300,gl.pts[6].y);
	gl.pts[7] = rotatePoint(gl.pts[6],temp,toRadians(-degrees));
	printCircNum(7,7);
	drawLine(6,7);
	
	let x = ((gl.pts[2].x-gl.pts[1].x)/2)+gl.pts[1].x;
	let yOffset = 140;
	gl.pts[8] = new Point(x, gl.pts[2].y+yOffset);
	printCircNum(8,8);
	gl.pts[9] = new Point(x, gl.pts[6].y-yOffset);
	printCircNum(9,9);
	s = { color: "saddlebrown",
	      numSteps: 40 };
	thing = new StringThing(s);
	drawParabs(thing,[
	    [1,0,4,5],
	    [2,3,7,6],
	    [1,0,9,8],
	    [4,5,9,8],
	    [2,3,9,8],
	    [7,6,9,8]
		  ]);
}
    
                   ///////////////////////////////////
                   // Figure 99:
                   ///////////////////////////////////
////////////////////////////////////////////////////////////////////////      
// FIGURE 99
    function figure99() {
	printTitle("Figure 99");
	gl.final=true;
        let x = 50;
	let y = 100;
	let yOffset = 100;
	let xRight = x+500;
	let yLeft  = y+500;
	context.fillStyle="black";
	gl.pts[0] = new Point(x,y);
	gl.pts[1] = new Point(x,yLeft);
	gl.pts[2] = new Point(xRight+100, y+yOffset);
	gl.pts[3] = new Point(xRight, yLeft-yOffset);
	for (i=0; i < gl.pts.length; i++) {
	    printCircNum(i);
	}
	drawLine(0,2,"red",4);
	drawLine(2,1,"red",4);
	drawLine(1,3,"red",4);
	drawLine(3,0,"red",4);
	s = { color: "blue",
	      numSteps: 25 };
	thing = new StringThing(s);
	drawParabs(thing,[
	    [2,0,3],
	    [3,1,2],
	    [0,2,1],
	    [1,3,0]
	]);
    }


                   ///////////////////////////////////
                   // Figure 151:
                   ///////////////////////////////////
    function figure151(){
	let distance   = 40;
	gl.final = true;
	function drawIt(ORIGIN) {
            let lineLength = 150;
	    let degrees = 45;
	    let x = ORIGIN.x;
	    let y = ORIGIN.y;
	    setPt(ORIGIN);
	    //segment 0 to 1
	    setPt(rotatePoint(ORIGIN,
			      new Point(x+lineLength,y),
			      -toRadians(degrees)));
	    //segment 2 to 3
	    setPt(new Point(gl.pts[gl.ctr-1].x,   gl.pts[gl.ctr-1].y+distance));
	    setPt(rotatePoint(gl.pts[gl.ctr-1],
			      new Point(gl.pts[gl.ctr-1].x - lineLength,gl.pts[gl.ctr-1].y),
			      toRadians(45)));
	    //segment 4 to 5
	    setPt(new Point(gl.pts[gl.ctr-2].x+distance,   gl.pts[gl.ctr-2].y));
	    setPt(rotatePoint(gl.pts[gl.ctr-1],
			      new Point(gl.pts[gl.ctr-1].x + lineLength,gl.pts[gl.ctr-1].y),
			      -toRadians(45)));
	    //segment 6 to 7
	    setPt(new Point(gl.pts[gl.ctr-2].x,   gl.pts[gl.ctr-2].y-distance));
	    setPt(rotatePoint(gl.pts[gl.ctr-1],
			      new Point(gl.pts[gl.ctr-1].x + lineLength,gl.pts[gl.ctr-1].y),
			      toRadians(45)));
	}

	printTitle("Figure 151");
	let ORIGIN = new Point(50,50);
	context.fillStyle="black";
	drawIt(ORIGIN);
	s = { numSteps: 20,
	      lineWidth: 1,
	      color:    blue
	    };
	thing=new StringThing(s);
	drawParabs(thing,[ [0,1,2,3],
			   [3,2,4,5],
			   [5,4,6,7],
			   [7,6,1,0] ]);

	drawIt(new Point(gl.pts[7].x+distance,50));
	drawParabs(thing,[ [8,9,10,11],
			   [11,10,12,13],
			   [13,12,14,15],
			   [15,14,9,8] ]);

	drawIt(new Point(gl.pts[3].x,gl.pts[3].y+distance));
	drawParabs(thing,[ [16,17,18,19],
			   [19,18,20,21],
			   [21,20,22,23],
			   [23,22,17,16] ]);

	drawIt(new Point(gl.pts[23].x+distance,gl.pts[23].y));
	drawParabs(thing,[ [24,25,26,27],
			   [27,26,28,29],
			   [29,28,30,31],
			   [31,30,25,24] ]);	
	drawParabs(thing,[ [4,5,23,22],
			   [22,23,24,25],
			   [25,24,11,10],
			   [10,11,5,4] ]);
	thing.lineWidth = .5;
	drawParabs(thing,[ [0,23,22],
			   [22,23,29],
			   [29,11,10],
			   [10,11,0],
			   [15,5,4],
			   [4,5,19],
			   [19,24,25],
			   [25,24,15]]);
	thing.lineWidth = .2;
	drawParabs(thing, [ [2,3,30,31],
			    [7,6,27,26],
			    [8,9,21,20],
			    [13,12,16,17]
			  ]);	
	//	printCircNum(rotatePoint(a,c,angle));
    }

                   ///////////////////////////////////
                   // Figure 158: 
                   ///////////////////////////////////
    function figure158() {
	printTitle("Figure 158");
//	gl.final = true;
	context.fillStyle="black";
	let mid = new Point(300,300);
	s = {numSteps: 20,
	     numNodes: 6,
	     midpoint: mid,
	     color: "blue",
	     rotate: 30,
	       lineWidth: .4
	      }
	thing      = new StringThing(s);
	let nodes = createPrintNodes(thing);
	// create an arm for each spoke 
	let Arm1 = [];
	for (i=0; i < gl.pts.length; i++) Arm1.push(ptsOnLine(thing.numSteps,mid,gl.pts[i]));

	// now create each of the loops
	let Arm2 = [];
	for (i=0; i < gl.pts.length; i++) {
	    j = (i+1) % gl.pts.length;
	    Arm2.push(arcPoints(gl.pts[j], gl.pts[i], .7, thing.numSteps+1));
	}
	// draw outside
	for (i=0;i<Arm2.length;i++) {
	    for (let j=0; j<Arm2[i].length-1;j++)
                drawLine(Arm2[i][j],Arm2[i][j+1],"blue");
	}
	let loops = [];
	let temp = [];
	
	// all three elements of the loop combined into one array
	for (i=0; i<nodes.length; i++){
	    k = (i+1) % nodes.length;
	    temp1 = Arm2[i].toReversed();
	    temp2 = Arm1[i].concat(temp1);
	    temp3 = Arm1[k].toReversed();
	    temp4 = temp2.concat(temp3);
	    loops[i] = temp4;
	}
	// the number added is how far into arc to begin drawing
	startPos = thing.numSteps + 2;
	color = "blue";
	for (i=0;i < loops.length; i++) {
            j=0;
	    while ((j+startPos) < loops[i].length) {
		drawLine(loops[i][j],
			 loops[i][j+startPos],color);
		if ((j+startPos) < loops[i].length-1) {
		    if (comparePoints(loops[i][j],
				      loops[i][j+1]))          j++;
		    if (comparePoints(loops[i][j+startPos],
				      loops[i][j+startPos+1])) j++;
		}
		j++;
	    }
	}
	color = "green";
	for (i=0;i < loops.length; i++) {
	    length = loops[i].length;
	    armLength = Arm1[i].length;
	    temp = loops[i].slice(-armLength);
	    temp1 = loops[i].slice(0,armLength);
	    loops[i] = temp.concat(loops[i]);
	    loops[i] = loops[i].concat(temp1);
	    for (j=0;j<length;j+=2) {
		drawLine(loops[i][j],
			 loops[i][j+armLength+1],color);
		if (comparePoints(loops[i][j],
				  loops[i][j+1]))          j++;
		if (comparePoints(loops[i][j+startPos],
				  loops[i][j+startPos+1])) j++;
	    }

	}
    }

                   ///////////////////////////////////
                   // Figure 172: SQUARE SINE
                   ///////////////////////////////////
    function squareSine() {
	printTitle("Figure 172: Square Sine");
	function doBox(s) {
            let pt1     = new Point(s.pt.x,     s.pt.y + s.dy);	    
	    let pt2     = new Point(pt1.x+s.dx, pt1.y)
	    s.dy = -s.dy;
	    let pt3     = new Point(pt2.x,      pt2.y + s.dy);
	    drawLine(s.pt,pt1,"blue");
	    drawLine(pt1, pt2,"blue");
	    drawLine(pt2, pt3,"blue");
            
	    let arm1    = ptsOnLine(s, s.pt, pt1);
	    let arm2    = ptsOnLine(s, pt1,  pt2);
	    let arm3    = ptsOnLine(s, pt2,  pt3);
	    let nodes = arm1.concat(arm2.concat(arm3));
	    for (let i = 0; i < s.numSteps+1; i++) {
		drawLine(nodes[i],nodes[2*arm1.length + i],"blue");
		drawLine(nodes[i],nodes[2*arm1.length - i - 1],"blue");
		drawLine(nodes[i+arm1.length+1],
			 nodes[3*arm1.length -i -1], "blue");
	    }

	    s.pt = pt2;
	    return s;
	}

	s = { numSteps: 15,
	      dx: 150,
	      dy: -150,
	      pt: new Point(-75, 200)
	    };
	for (let i=0;i<7;i++) s = doBox(s);	
	s.pt=new Point(-75, 200)
	for (i=0;i<7;i++) s = doBox(s);
	s.pt=new Point(-75, 500)
	for (i=0;i<7;i++) s = doBox(s);
	
    }

                   ///////////////////////////////////
                   // Figure 173:
                   ///////////////////////////////////
    function figure173() {
	printTitle("Figure 173");
	mid = new Point(250,300);
	numNodes = 232;
	s = { radius:   150,
	      color:    "green",
	      midpoint: mid,
	      rotate:   90,
	      numNodes: numNodes
	    };
	step = numNodes/4;
	thing = new StringThing(s);
	nodes = createNodes(thing);
	s = { radius:   325,
	      color:    "green",
	      midpoint: mid,
	      numSteps: (numNodes/4) - 1,
	      rotate:   45,
	      numNodes: 4
	    };
	thing = new StringThing(s);
	nodesSquare = createNodes(thing);
	k = 0;
	steps = thing.numSte
	for (let i=0; i<nodesSquare.length; i++) {
	    j = i+1;
	    if (j==4) j = 0;
	    thing.arm1 = ptsOnLine(thing.numSteps,nodesSquare[i],nodesSquare[j]);
	    thing.arm2 = nodes.slice(k,k+step);
	    k+=step;
	    stitcher(thing);
	    drawLine(nodesSquare[i],nodesSquare[j],thing.color);
	}
	mid = new Point(200,350);
	for (i=0;i<nodes.length;i+=2) {
	    drawLine(mid,nodes[i],"#6bb56b");
	}
    }

                   ///////////////////////////////////
                   // Figure 177:
                   ///////////////////////////////////
    function figure177(){
	printTitle("Figure 177");
	s = { color: blue,
	      midpoint: new Point(250,250),
	      radius:   300,
	      numNodes: 4,
	      rotate:   45,
	      numSteps: 36
	    }
	thing = new StringThing(s);
	nodes = createNodes(thing);
	for (i=0; i < nodes.length; i++) {
	    j = (i+1) % nodes.length;
	    drawLine(nodes[i],nodes[j], blue);
	}
	arms = [];
	for (i=0;i<nodes.length;i++) {
	    j = (i+1) % nodes.length;
	    arms.push(ptsOnLine(thing.numSteps,nodes[i],nodes[j]));
	}
	arm = arms[0];
	for (i=1;i<arms.length;i++) {
	    arm = arm.concat(arms[i]);
	}
	arm = arm.concat(arm);
	for (i=0; i<6*arms[0].length; i++) {
            drawLine(arm[i],arm[i+arms[0].length+18],blue);
	}
	    
    }
    
                   ///////////////////////////////////
                   // Figure 204: 
                   ///////////////////////////////////
    function figure204() {
	printTitle("Figure 204");
	radius = 200;
	center = new Point(200,250);
	s = { midpoint:   center,
	      numNodes:   100,
	      skip:       60,
	      startSkip:  -200,
	      endSkip:    -100,
	      withinCirc: TAPER,
	      color:      "blue",
	      radius:     radius
	    };
	thing = new StringThing(s);
	drawInCircle(thing);
    }

                   ///////////////////////////////////
                   // Figure 205:
                   ///////////////////////////////////
    function figure205() {
	printTitle("Figure 205");
	radius = 200;
	center = new Point(200,227);
	s = { midpoint:     center,
	      numNodes:     200,
	      rotate:       0,
	      skip:         30,
	      startSkip:    16,
	      endSkip:      25,
	      withinCirc:   START_END,
	      color:        "black",
	      radius:       radius };
	thing = new StringThing(s);
	drawInCircle(thing);

	s = { midpoint:     center,
	      numNodes:     200,
	      rotate:       -45,
	      skip:         64,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "#5a6673",
	      radius:       radius };
	thing = new StringThing(s);
	drawInCircle(thing);

	s = { midpoint:     center,
	      numNodes:     200,
	      rotate:       180,
	      skip:         50,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "#bac2ca",
	      radius:       radius };
	thing = new StringThing(s);
	drawInCircle(thing);
    }

                   ///////////////////////////////////
                   // Figure 206a:
                   ///////////////////////////////////
    function figure206a(){
	printTitle("Figure 206a");
	radius = 200;
	center = new Point(200,227);
	s = { midpoint:     center,
	      numNodes:     200,
	      skip:         20,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "blue",
	      radius:       radius };
	thing = new StringThing(s);
	nodes = createNodes(thing);
	drawLines(nodes,0,nodes.length,"blue", CLOSE);
	ptLeft   = new Point(center.x-radius,center.y);
	ptRight  = new Point(center.x+radius,center.y);
	armLeft  = ptsOnLine(thing.numSteps,center,ptLeft);
	armRight = ptsOnLine(thing.numSteps,center,ptRight);
	nodesTop = nodes.slice(0,nodes.length/2);
	nodesBottom = nodes.slice(nodes.length/2,nodes.length);

	thing.arm1 = armLeft;
	thing.arm2 = nodesTop.toReversed();
	stitcher(thing);

	thing.arm1 = armRight;
	thing.arm2 = nodesBottom.toReversed();
	stitcher(thing);

	numNodes = 160;
	s = { midpoint:     center,
	      numNodes:     numNodes,
	      skip:         20,
	      startSkip:    numNodes/8,
	      endSkip:      numNodes/2,
	      withinCirc:   START_END,
	      color:        "blue",
	      radius:       radius
	    };
	thing = new StringThing(s);
	drawInCircle(thing);

	numNodes = 160;
	s = { midpoint:     center,
	      numNodes:     numNodes,
	      skip:         20,
	      startSkip:    5*numNodes/8,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "blue",
	      radius:       radius
	    };
	thing = new StringThing(s);
	drawInCircle(thing);

	let pts = armRight.concat(nodesTop);
	skip = 48;
	drawLinesAround(pts,skip,"brown");

	skip = 70;
	pts = nodesTop.concat(armLeft.toReversed());
	pts = pts.concat(armRight);
        drawLinesAround(pts,skip,"slategray");

	pts = armLeft.concat(nodesBottom);
	skip = 48;
	drawLinesAround(pts,skip,"brown");

	skip = 70;
	pts = nodesBottom.concat(armRight.toReversed());
	pts = pts.concat(armLeft);
        drawLinesAround(pts,skip,"slategray");	

    }
                   ///////////////////////////////////
                   // Figure 209:
                   ///////////////////////////////////
    function figure209() {
	printTitle("Figure 209");
	radius = 200;
	center = new Point(200,227);
	s = { midpoint:     center,
	      numNodes:     150,
	      rotate:       0,
	      skip:         40,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "#5a6673",
	      radius:       radius };
	thing = new StringThing(s);
	pt = new Point(center.x+radius, center.y);
	thing.numPoints = 21;
	thing.arm1 = ptsOnLine(thing.numSteps,center,pt);
	arm1 = thing.arm1;
	drawInCircle(thing);
      
	s = { midpoint:     center,
	      numNodes:     150,
	      rotate:       0,
	      skip:         21,
	      startSkip:    30,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "black",
	      radius:       radius };
	thing = new StringThing(s);
	thing.numPoints = 21;
	thing.arm2 = ptsOnLine(thing.numSteps,pt,center);
	arm2 = thing.arm2;
	drawInCircle(thing);

	s = { midpoint:     center,
	      numNodes:     150,
	      lineWidth:    .3,
	      skip:         50,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "#acb5bf",
	      radius:       radius };
	thing = new StringThing(s);
	drawInCircle(thing);


 	s = { midpoint:     center,
	      numNodes:     150,
	      skip:         50,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   START_END,
	      color:        "black",
	      radius:       radius };
	thing = new StringThing(s);
	nodes = createNodes(thing);
	drawLine(nodes[0],nodes[nodes.length-1], "black");
	thing.arm1 = arm1;
	start = nodes.length/4;
	end   = start+22;
	thing.arm2 = nodes.slice(start,end);
	stitcher(thing);
	
	thing.arm1 = null;
	thing.arm1 = arm2;
	start = 3*nodes.length/4-2;
	end   = start+22;
	thing.arm2 = nodes.slice(start,end);
	stitcher(thing);
	
    }


                   ///////////////////////////////////
                   // Figure 209a:
                   ///////////////////////////////////
    function figure209a() {
	printTitle("Figure 209a");
	radius = 200;
	center = new Point(200,227);
	s = { midpoint:     center,
	      numNodes:     200,
	      skip:         20,
	      startSkip:    0,
	      endSkip:      0,
	      withinCirc:   FULL,
	      color:        "black",
	      radius:       radius };
	thing = new StringThing(s);
	nodes = createNodes(thing);
	drawLines(nodes,0,nodes.length,"blue", CLOSE);
	skip = 16;
	ctr  = 0;
	for (let i=0; i < 2*nodes.length; i++) {
	    j = i;
	    j = j % nodes.length;
	    k = i+skip;
	    k = k % nodes.length;
	    drawLine(nodes[j], nodes[k], "blue");
	    ctr++;
	    if (ctr==10){
		skip+=2;
		ctr = 0;
	    }
	}
    }


                   ///////////////////////////////////
                   // Figure 209a:
                   ///////////////////////////////////
    function figure209test() {
	printTitle("Figure 209test");
	let radius = 200;
	let center = new Point(200,227);
	let skip   = 80;
	s = { midpoint:     center,
	      numNodes:     200,
              rotate:       40,
	      skip:         skip,
	      startSkip:    -5,
	      endSkip:      0,
	      withinCirc:   START_TAPER,
	      color:        "blue",
	      radius:       radius };
	let thing = new StringThing(s);
	let nodes = createEllipseNodes(thing).toReversed();
	drawLinesIncreasing(nodes,skip,blue)
    }

                   ///////////////////////////////////
                   // Figure 237:
                   ///////////////////////////////////
    function figure237() {
	function toColor(color,percent) {
	    let num = Math.round((percent/100)*255).toString(16);
	    return (color+num);
	}
	
	function callStitcher(thing,arm1,arm2,numNodes){
	    for (i=0;i<numNodes;i++) {
		thing.arm1 = arm1[i];
		thing.arm2 = arm2[i];
		stitcher(thing);
		
		j = i-1;
		if (j < 0) j = numNodes-1;
		thing.arm2 = arm2[j].toReversed();
		stitcher(thing);
	    }
	}

	function drawCircParab(thing) {
	    let pt         = new Point(thing.midpoint.x, thing.midpoint.y);
	    const nodes    = createNodes(thing);
	    let numNodes   = thing.numNodes;
	    
	    arm1 = [];
	    for (i=0; i<numNodes; i++) {
		arm1.push(ptsOnLine(thing.numSteps,thing.midpoint,nodes[i]));
	    }

	    // numNodes now equals total number of steps around circle
	    thing.numNodes = thing.numNodes*thing.numSteps;
            const circleNodes  = createNodes(thing);
	    drawNodes(thing,circleNodes);


	    arm2 = [];
	    base = 0;
	    // create an array where each element is a part of the circle
	    for (i=0; i < numNodes; i++) {
		pts = [];
		let k;
		for (j = 0; j < thing.numSteps+1; j++) {
		    k = (base+j) % thing.numNodes;
		    pts.push(circleNodes[k]);
		}
		base += thing.numSteps;
		arm2.push(pts);
	    }

// DRAW TWIST
	    shortArms =[];
	    for (i=0; i < numNodes; i++) {
		shortArms.push(arm1[i].slice(0,5));
	    }
	    
	    arms1a = [];
	    for (i=0; i < numNodes; i++) {
		j = i+1;
		j = j % numNodes;
		temp = shortArms[i].toReversed();
		temp.length = temp.length-1;
		arms1a.push(temp.concat(shortArms[j]));
	    }
	    shortTop = [];
	    for (i=0; i < numNodes; i++) {
		shortTop.push(arm2[i].slice(5,15));
	    }

	    thing.color = "white";
	    for (i=0; i < numNodes; i++) {
		thing.arm1 = arms1a[i];
		thing.arm2 = shortTop[i].toReversed();
		stitcher(thing);
	    }
	    
// DRAW INNER OTHER
	    shortArms = [];
	    for (i=0; i < numNodes; i++) {
		shortArms.push(arm1[i].slice(0,9));
	    }
	    shortTop = [];
	    for (i=0; i < numNodes; i++){
		j = i+1;
		j = j % numNodes;
		temp = arm1[j].slice(-5);
		temp = temp.toReversed();
		shortTop[i] = arm2[i].slice(-5);
		shortTop[i] = shortTop[i].concat(temp);
	    }
	    thing.color = "lightslategray";
	    for (i=0; i < numNodes; i++) {
		thing.arm1 = shortArms[i];
		thing.arm2 = shortTop[i];
		stitcher(thing);
	    }

	    for (i=0; i < numNodes; i++) {
		j = i+1;
		j = j % numNodes;
		temp = arm1[i].slice(-5);
		temp = temp.toReversed();
	    	shortTop[j] = arm2[j].slice(-5);
		shortTop[j] = shortTop[j].concat(temp);
	    }
	    for (i=0; i < numNodes; i++) {
		thing.arm1 = shortArms[i];
		thing.arm2 = shortTop[i];
		stitcher(thing);
	    }
	    
// DRAW INNER PARABOLA 1
	    thing.color = "blue";
	    thing.color = "lightgray";
            thing.numNodes = numNodes;
	    callStitcher(thing,arm1,arm2,numNodes);

	    // draw inner parabola 2
	    for (i=0;i<numNodes;i++) {
		arm1[i]=arm1[i].slice(4);
	    }
	    thing.color = "#6b6bff";
	    callStitcher(thing,arm1,arm2,numNodes);

	    // draw inner parabola 3
	    for (i=0;i<numNodes;i++) {
		arm1[i]=arm1[i].slice(4);
	    }
	    thing.color = "#b8b8ff";
	    callStitcher(thing,arm1,arm2,numNodes)
	}


//	showColors(blue,300);
	printTitle("Figure 237");
	color = colourNameToHex("blue");
	s = {
	    numNodes: 8,
	    midpoint: new Point(225,250),
	    color:    color
	};
	thing = new StringThing(s);
	drawCircParab(thing);
	
    }


                   ///////////////////////////////////
                   // Figure 242:
                   ///////////////////////////////////
    function figure242() {
	printTitle("Figure 242");
	  s = { numNodes:   150,
		midpoint:   new Point(350, 400),
		color:      "blue",
		numCycloids: 4,
		radius:      300
	      }

	thing = new StringThing(s);
	drawCycloid(thing);
	thing.rotate = 30;
	drawCycloid(thing);
	thing.rotate = 60;
	drawCycloid(thing);
	thing.rotate = 90;
	drawCycloid(thing);
    }

                   ///////////////////////////////////
                   // Figure 245:
                   ///////////////////////////////////
    function figure245(){
	printTitle("Figure 245");
	radius = 150;
	center = new Point(200,200);
	s = { midpoint: center,
	      numNodes: 100,
	      skip:     16,
	      rotate:   90,
	      color:    "blue",
	      radius:   radius };
	thing = new StringThing(s);
	drawCircle(center,radius,"blue");
	drawInCircle(thing);
	
	nodes=createNodes(thing);
	lineNodes = ptsOnLine(30,nodes[50],nodes[0]);

	sliced = nodes.slice(50,100).reverse();
	around = lineNodes.concat(sliced);
	around = around.concat(lineNodes);
	drawLinesAllAround(around,30,"#6b6bff");

	around = around.slice(8,around.length-8);
	drawLinesAllAround(around,22,"#b8b8ff");

	sliced = nodes.slice(0,50);
	around = lineNodes.concat(sliced);
	around = around.concat(lineNodes);
	drawLinesAllAround(around,30,"#6b6bff");

	around = around.slice(8,around.length-8);
	drawLinesAllAround(around,22,"#b8b8ff");
    }

                   ///////////////////////////////////
                   // Figure 246:
                   ///////////////////////////////////
    function figure246() {
	printTitle("Figure 246");	
	radius = 150;
	center = new Point(200,180);
	numNodes = 100;
	s = { midpoint: center,
	      numNodes: numNodes,
	      skip:     16,
	      rotate:   90.5,
	      color:    "blue",
	      radius:   radius };
	thing = new StringThing(s);
	drawCircle(center,radius,"blue");
	drawInCircle(thing);
	// separately create nodes for circle and line
	nodes      = createNodes(thing);
	let right = nodes.slice(nodes.length/2,nodes.length);
	let left  = nodes.slice(0,nodes.length/2);
	left.reverse();
	
	lineNodes = ptsOnLine((numNodes/2)-9,nodes[0],nodes[numNodes/2]);
	length = Math.round(lineNodes.length/2+3);
	topDiff = 4;
	bottomDiff = 2;
	colors = ["#cb8383","#6b6bff","#6bb56b","#ff6b6b","#cccc00" ];
	start = 0;
	end   = 0;
	for (i=0; i< colors.length; i++){
	    thing.color = colors[i];
	    arm         = lineNodes.slice(start,length+end);
	    thing.arm1  = arm;
	    thing.arm2  = right;
	    stitcher(thing);
	    thing.arm2  = left;
	    stitcher(thing);
	    start +=topDiff;
	    end   +=bottomDiff;
	}


	s = { midpoint: center,
	      numNodes: numNodes,
	      skip:     16,
	      rotate:   271,
	      color:    "blue",
	      radius:   radius };
	thing = new StringThing(s);
	nodes      = createNodes(thing);
	right = nodes.slice(nodes.length/2,nodes.length);
	left  = nodes.slice(0,nodes.length/2);
	left.reverse();
	lineNodes  = ptsOnLine((numNodes/2)-9,nodes[0],nodes[(numNodes/2)]);
	length = Math.round(lineNodes.length/2+3);
 	start = 0;
	end   = 0;
	for (i=0; i< colors.length; i++){
	    thing.color = colors[i];
	    arm         = lineNodes.slice(start,length+end);
	    thing.arm1  = arm;
	    thing.arm2  = right;
	    stitcher(thing);
	    thing.arm2  = left;
	    stitcher(thing);
	    start +=topDiff;
	    end   +=bottomDiff;
	}
   }

    
                   ///////////////////////////////////
                   // Figure 250:
                   ///////////////////////////////////
   function figure250() {
	printTitle("Figure 250");
	s = { color:       "#3838ff",
	      withinCirc:  TAPER,
//	      withinCirc:  START_END,
	      ellipse:  {a: 140, b: 250 },
	      midpoint: new Point(250,200),
//	      numNodes: 160,
	      numNodes: 120,
	      endSkip:  -10,
	      startSkip: -10,
//	      skip:     60
	      skip:     35
	    };
	thing = new StringThing(s);
	drawInEllipse(thing);
	
	s = { color:       "#9e9eff",
	      withinCirc:  TAPER,
	      ellipse:     {a: 140, b: 250 },
	      midpoint:    new Point(250,200),
//	      numNodes:    160,
	      numNodes:    120,
	      startSkip:   20,
	      endSkip:     20,
	      skip:        30
	    };
	thing = new StringThing(s);
	drawInEllipse(thing);
	
       s = { color: "red",
	   color:       "#6b6bff",
	      withinCirc:  TAPER,
//	      withinCirc:  START_END,
	      rotate:      270,
	      ellipse:    {a: 140, b: 250 },
	      midpoint:    new Point(250,200),
	      numNodes:    160,
	      startSkip:   20,
	      endSkip:     20,
	      skip:        20
	    };
	thing = new StringThing(s);
	drawInEllipse(thing);
    }
    
                   ///////////////////////////////////
                   // Figure 255:
                   ///////////////////////////////////
    function figure255() {
      function radiate(r){
	  let color           = context.strokeStyle;
	  let lineWidth       = context.lineWidth;
	  context.strokeStyle = r.color;
	  context.lineWidth   = r.lineWidth;
	  for (let i=0; i < r.nodes.length-1; i+=2) {
	      drawLine(r.start,r.nodes[i],r.color);
//	      moveTo(r.start.x,    r.start.y);
// lineTo(r.nodes[i].x, r.nodes[i].y);
	  }
	  stroke();
	  closePath();
	  context.strokeStyle = color;
	  context.lineWidth = lineWidth;
      } // end drawRadiate


	printTitle("Figure 255");
	s = { numNodes: 36,
	      rotate:   90,
	      midpoint: new Point(225,250),
	      color: blue
	    };
	thing = new StringThing(s);
	nodes = createNodes(thing);
	length = nodes.length;
//	nodes = nodes.concat(nodes);
	s = { color: blue,
	      start: nodes[0],
	      nodes: nodes.slice(9,29)
	    };
	r = new StringThing(s);
	j=0;
	for (i=1;i<length-18;i++) {
	    r.start = nodes[i];
	    r.nodes = nodes.slice(i+8,j+20);
	    radiate(r);
	    j++;
	}
	i = length-1;
	j = length;
	r.color = "green";
	while (i > length/2) {
	    r.start = nodes[i];
	    r.nodes = nodes.slice(i-16,length-8);
	    radiate(r);
	    j--;
	    i--;
	}
	r.color = "gray";
	r.start = nodes[0];
	r.nodes = nodes.slice(9,18);
	drawRadiate(r);
	r.nodes = nodes.slice(20,28);
	drawRadiate(r);
    }


                   ///////////////////////////////////
                   // test 7:  ARC POINTS
                   ///////////////////////////////////
    function figure255d() {

	printTitle("Figure 255d");
	colors = ["#0000a3",
		  "#0000e0",
		  "#3838ff",
		  "#8585ff",
		  "#b8b8ff",
		  "#8585ff",
		  "#3838ff",
		  "#0000e0",
		  "#0000a3"];
       pt1 = new Point(100,100);
       pt2 = new Point(500,100);
       curvature = 3;
       numPoints = 8;
       let pts1 = arcCurvature(pt1, pt2, curvature, numPoints);
       
       pt1 = new Point(25, 500);
       pt2 = new Point(575,500);
       curvature = -2.8;
       numPoints = 17;
       pts2 = arcCurvature(pt1, pt2, curvature, numPoints);

       start = 0;
       for (i=0; i < pts1.length; i++) {
	   for (j=start; j < start+10; j++) {
	       drawLine(pts1[i],pts2[j],colors[i]);
	   }
	   start++;
       }
       for (i=0;i<pts2.length -1; i++) {
	   drawLine(pts2[i],pts2[i+1]);
       }
    }

    function figure255k(){
	printTitle("Figure 255k");
	s = { color: "blue",
	      numNodes: 200,
	      radius:   280,
	      rotate:   35,
	      midpoint: new Point(300,330)
	    };
	thing = new StringThing(s);
	nodes = createNodes(thing);
	drawNodes(nodes,thing.color);
	numBundles     = 13;
	linesInBundle  = 20;
	startTop       = 160;
	startBot = nodes.length - 20;
	for (i=0; i< numBundles; i++) {
	    for (j = startTop; j < startTop+linesInBundle; j++) {
		k = j % nodes.length;
		l = (j+startBot) % nodes.length;
		drawLine(nodes[k],nodes[l]);
	    }
	    startTop += linesInBundle/2;
	    startBot = startBot - linesInBundle + 7;
	}
    }


                  ///////////////////////////////////
                   // figure 282: FULL ELLIPSE
                   ///////////////////////////////////
    function figure282() {
	printTitle("Figure 282");
	s = { midpoint:    new Point(370,250),
	      color:       "lightblue",
	      skip:        55,
//	      startSkip:   10,
	      startSkip:   -50,
//	      endSkip:     10,
	      endSkip:     -50,
	      withinCirc:  TAPER,
	      ellipse:     {a: 225, b: 350},
	      numNodes:    150,
	    };
	thing = new StringThing(s);
        drawInEllipse(thing);
	s = { midpoint:    new Point(370,250),
	      color:       blue,
	      skip:        55,
//	      startSkip:   10,
	      startSkip:   -10,
//	      endSkip:     10,
	      endSkip:     -10,
	      withinCirc:  TAPER,
	      ellipse:     {a: 225, b: 350},
	      numNodes:    150,
	    };
	thing = new StringThing(s);
        drawInEllipse(thing);
      }    
/////////////////////////////////////////////////////////////////  
/////////////////////////////////////////////////////////////////  
// TESTS AND FIGURES GO ABOVE HERE
/////////////////////////////////////////////////////////////////  
/////////////////////////////////////////////////////////////////  


      drawScreen();
}



</script> 
</head>
<body>
<div style="position: absolute; top: 50px; left: 50px;">
<canvas id="StringThing" width="1000" height="800">

 Your browser does not support HTML 5 Canvas. 
</canvas>
</div>
<script src="utility.js"></script>
</body>
</html>
