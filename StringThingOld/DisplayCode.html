<pre>
    function drawInEllipse(thing) {

	function drawStart(nodes, skip, color, start, dist=4) {
	    // inc gives a slight small setting to the distance
	    // between the start and end positions of the line
	    let inc = dist;
	    let i = start;
	    for (; i < start+ skip - dist; i++) {
		// inc being equal to zero is really a flag
		// saying "just find the end of the taper
		// without drawing a line
		if (dist != DONT_DRAW) {
		    let j = i % nodes.length;
		    let k = (i+inc) % nodes.length;
		    drawLine(nodes[j],nodes[k],color);
		    inc++;
		}
	    }
	    return i;
	}
	
	function drawWithin(nodes, skip, color, withinCirc,
			    length=START_END, start=0, dist=4) {
	    let i = start;
	    let numNodes;
	    if (length == START_END)
		numNodes = nodes.length;
	    else
		numNodes = length;
	    // if, for example, skip is 20 and there are
	    // 100 nodes, the last line drawn is from
	    // 80 to 100
	    numNodes -= skip;
	    for (; i < start+numNodes; i++) {
		let j = i % nodes.length;
		let k = (i+skip) % nodes.length;
		drawLine(nodes[j],nodes[k],color);
	    }
	    return i;
	}

	function drawEnd(nodes, skip, color, start, dist=4) {
	    let end = start+2*(skip-dist)-1;
            let j;
	    for (let i=start, j=0; j<end; i+=2) {
		skip--;
		j = i % nodes.length;
		k = (i+skip+1) % nodes.length;
		drawLine(nodes[j],nodes[k],color);
	    }
	}

	const DISTANCE = 4;
	let color  = thing.color;
	let skip   = thing.skip;
	let nodes  = createEllipseNodes(thing);
	let start  = 0;
	let end    = nodes.length;
	             // length = total of nodes to be done
	             // it will be greater than nodes.length
	             // if startSkip or endSkip is negative
	let length = end;

// COMPLETE CIRCLE
	if (thing.withinCirc == FULL) {
	    drawLinesAllAround(nodes,skip,color);
	    drawNodes(nodes,color);
	    return;
	}

// if adding an arm at the beginning of end	
// must be withinCirc = START_END

	if (Array.isArray(thing.arm1) || Array.isArray(thing.arm2))	
	    thing.withinCirc = START_END;

	if (Array.isArray(thing.arm1) ||
	    Array.isArray(thing.arm2))   {
	    if (Array.isArray(thing.arm1)) {
		// Im assuming that end point of grafted
		// line shares a point on the circle
		nodes.shift();
		nodes = thing.arm1.concat(nodes);
	    }
	    if (Array.isArray(thing.arm2)) {
		nodes = nodes.concat(thing.arm2);
	    }
	    drawWithin(nodes,skip,color,thing.withinCirc);
	    return;
	}
  
	if (thing.startSkip > 0) {
	    start  = thing.startSkip;
	    length = length - thing.startSkip;
	} else if (thing.startSkip < 0) {
	    // if startSkip is negative, starting position is at
	    // that number of points from the end of "nodes"
	    start   = end + thing.startSkip;    // startSkip is negative
	    length  = length - thing.startSkip
	}
	if (thing.endSkip > 0) {
	    end    = end - thing.endSkip;
	    length = length - thing.endSkip;
	} else if (thing.endSkip < 0) {
            end    = end - thing.endSkip;           // endSkip is negative
	    length = length - thing.endSkip;
	}
	let ctr = 0;
	for (let i=start; i < start+length-1; i++) {
	    j = i % nodes.length;
	    k = (i+1) % nodes.length;
	    drawLine(nodes[j],nodes[k],color);
	    ctr++;
	    if (ctr > nodes.length) break;	    
	}
	// START AND END WITHIN, NO TAPER
	if (thing.withinCirc == START_END) {
	    drawWithin(nodes,skip,color,thing.withinCirc, length, start);
	    return;
	}

	// DRAW START
//	if (thing.withinCirc == END_TAPER)
//	    // here we are using drawStart to return a position
//	    // it does not draw anything
//	    start = drawStart(nodes, skip, color, start, DONT_DRAW);
//	else
	if (thing.withinCirc == START_TAPER ||
	         thing.withinCirc == TAPER ) {
	    start = drawStart(nodes, skip, color, start, DISTANCE);
	    length -= start;
	}
        // DRAW MIDDLE
	if (thing.withinCirc == TAPER || thing.withinCirc == END_TAPER) {
	    let tempLength = length - skip + DISTANCE;
	    start = drawWithin(nodes, skip, color, thing.withinCirc,
			       tempLength, start);
	} else
	    start = drawWithin(nodes, skip, color, thing.withinCirc,
			       length, start);
	if (thing.withinCirc == TAPER || thing.withinCirc == END_TAPER) {
	    drawEnd(nodes,skip,color,start,DISTANCE);
	}
    }





    function drawInEllipse(thing) {

	function drawWithin(nodes, skip, color, withinCirc, start=0,dist=4) {
	    let j;
	    end = nodes.length - 1;
	    i = start;
	    if (withinCirc == END_TAPER) {
		end = end - skip;
	    } else if (withinCirc == TAPER) {
		i = start;
		end = end - skip;
	    }
	    for (; i &lt; end - skip; i++) {
		j = i+skip;
		drawLine(nodes[i],nodes[j],color);
	    }
	    return i;
	}
	
	function drawStart(nodes, skip, color, start=0, dist=4) {
	    inc = dist;
	    let i = start;
	    for (; i &lt; start + skip - dist; i++) {
		if (inc != 0) {
		    drawLine(nodes[i],nodes[i+inc],color);
		    k=i;
		    inc++;
		}
	    }
	    return i;
	}
	function drawEnd(nodes, skip, color, start, dist=4) {
	    let end = start+2*(skip-dist)-1;
//	    for (i=start; i&lt;end; i+=2) {
	    for (i=start, j=0; j&lt;end; i+=2) {
		skip--;
		j = i+skip+1;
		drawLine(nodes[i],nodes[j],color);
	    }
	    drawLines(nodes,start,end+3,color);
	}

	
	let color = thing.color;
	let skip  = thing.skip;

	let nodes = createEllipseNodes(thing);
// COMPLETE CIRCLE
	if (thing.withinCirc == FULL) {
	    drawLinesAllAround(nodes,skip,color);
//	    nodes = nodes.concat(nodes.slice(0,skip));
//	    drawWithin(nodes, skip, color,thing.withinCirc);
	    return;
	}
	
// START AND END WITHIN, NO TAPER
	if (thing.withinCirc == START_END) {

	    if (thing.endSkip &gt; 0)
		nodes.length = nodes.length - thing.endSkip;
	    if (thing.startSkip &gt; 0)
		nodes = nodes.slice(thing.startSkip);
	    drawLines(nodes,0,nodes.length,color);

	    if (thing.endSkip &lt; 0)
		startSlice = nodes.slice(0,-thing.endSkip);
	    if (thing.startSkip &lt; 0) 
		endSlice = nodes.slice(thing.startSkip);
	    
	    if (thing.endSkip &lt; 0)
		nodes = nodes.concat(startSlice);
	    if (thing.startSkip &lt; 0)
		nodes = endSlice.concat(nodes);
		
	    if (Array.isArray(thing.arm1)) {
		nodes.shift();
		nodes = thing.arm1.concat(nodes);
	    }
	    if (Array.isArray(thing.arm2)) {
//		nodes.pop();
		nodes = nodes.concat(thing.arm2);
	    }
	    drawWithin(nodes,skip,color,thing.withinCirc);
	    return;
	}

	// NOW IN TAPER; THE HARD PART
	if (thing.startSkip &gt; 0) 
	    start = thing.startSkip;
	else
	    start = 0;
	
	if (thing.endSkip &gt; 0)
	    nodes.length = nodes.length - thing.endSkip;
	
	// Positive taken care of already
	//     we take the end of the array and will soon
	//     prepend it. 
	if (thing.startSkip &lt; 0) 
	    startSlice = nodes.slice(thing.startSkip);
	  
	// if there is a negative endSkip, add the beginning
	// elements of nodes to the end, so when it gets
	// past the old length, the newly added nodes are
	// those from the begining
	//
	// if there is a negative startSkip, the origin is
	// in the last elements of node, so they are
	// prepended.
	//
	// if an endSkip and a startSkip, should also work
	//
	// Need to add to 
	if (thing.endSkip &lt; 0) {
	    // thing.endSkip is negative so need to change
	    // its sign. THIS IS THE BEGINNING OF THE ARRAY
	    endSlice = nodes.slice(0,-thing.endSkip);
	    nodes = nodes.concat(endSlice);
	}
	if (thing.startSkip &lt; 0)
	    nodes = startSlice.concat(nodes);
	
	let dist = 4;
	                 // DRAW START TAPER
	if (thing.withinCirc == END_TAPER)
	    start = drawStart(nodes, skip, color, start, 0);
	else
	    start = drawStart(nodes, skip, color, start, dist);
	
                         // DRAW MIDDLE
	start = drawWithin(nodes, skip, color, thing.withinCirc, start);

	                 // DRAW END TAPER
	if (thing.withinCirc == TAPER || thing.withinCirc == END_TAPER)
	        drawEnd(nodes,skip,color,start,dist);
    }
    </pre>
