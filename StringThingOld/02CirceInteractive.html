
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ellipse Curve Stitching</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin: 0; display:flex; height:100vh; }
  #ui { width: 300px; padding: 12px; box-sizing: border-box; background:#f7f7f8; border-right:1px solid #e0e0e0; }
  #canvasWrap { flex:1; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#fff,#fafafa); }
  canvas { max-width:100%; height:auto; display:block; }
  label { display:block; margin:8px 0 4px; font-size:13px; color:#333; }
  input[type="range"] { width:100%; }
  .row { display:flex; gap:8px; align-items:center; }
  .small { font-size:12px; color:#666; }
  button { margin-top:8px; padding:8px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
  .muted { color:#666; font-size:12px; }
</style>
</head>
<body>

<div id="ui">
  <h3>Stitch2: Ellipse Curve Stitching</h3>

  <label>Points: <span id="nLabel">200</span></label>
  <input id="n" type="range" min="10" max="1500" value="200" />

  <label>Skip (connect to i + skip): <span id="skipLabel">71</span></label>
  <input id="skip" type="range" min="1" max="749" value="71" />

  <div class="row">
    <div style="flex:1">
      <label>Stroke width: <span id="wLabel">0.8</span></label>
      <input id="width" type="range" min="0.1" max="4" step="0.1" value="0.8" />
    </div>
    <div style="width:72px">
      <label class="small">Color</label>
      <input id="color" type="color" value="#1b7bd6" />
    </div>
  </div>

  <label><input id="outline" type="checkbox" checked /> Show ellipse outline</label>
  <label><input id="points" type="checkbox" /> Show points</label>

  <label><input id="animate" type="checkbox" /> Animate (rotate / auto-skip)</label>

  <div style="margin-top:8px">
    <button id="fit">Fit to window</button>
    <button id="download">Download PNG</button>
  </div>

  <p class="muted">Tip: try prime or near-prime skips for interesting patterns. Use many points and a small skip for smooth "parabolic" curves.</p>
</div>

<div id="canvasWrap">
  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const controls = {
    n: document.getElementById('n'),
    skip: document.getElementById('skip'),
    color: document.getElementById('color'),
    width: document.getElementById('width'),
    outline: document.getElementById('outline'),
    points: document.getElementById('points'),
    animate: document.getElementById('animate'),
    nLabel: document.getElementById('nLabel'),
    skipLabel: document.getElementById('skipLabel'),
    wLabel: document.getElementById('wLabel'),
    fit: document.getElementById('fit'),
    download: document.getElementById('download')
  };

  // Hi-DPI scaling
  function resizeCanvasToDisplaySize() {
    const ratio = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * ratio);
    canvas.height = Math.round(rect.height * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  // Responsive initial sizing
  function fitCanvas() {
    const wrap = document.getElementById('canvasWrap');
    // take most of available space minus UI
    const w = Math.max(300, wrap.clientWidth * 0.95);
    const h = Math.max(300, wrap.clientHeight * 0.95);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    resizeCanvasToDisplaySize();
  }
  fitCanvas();
  window.addEventListener('resize', () => { fitCanvas(); draw(); });

  // Compute ellipse perimeter points
  function ellipsePoint(cx, cy, a, b, t) {
    return [cx + a * Math.cos(t), cy + b * Math.sin(t)];
  }

  // Build points array
  function buildPoints(n, cx, cy, a, b, rotation=0) {
    const pts = new Array(n);
    for (let i = 0; i < n; i++) {
      // parameter t runs from 0..2Ï€
      const t = (i / n) * Math.PI * 2 + rotation;
      pts[i] = ellipsePoint(cx, cy, a, b, t);
    }
    return pts;
  }

  // Draw everything
  let rotation = 0;
  let skipOffset = 0;

  function draw() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    // clear
    ctx.clearRect(0, 0, w, h);

    // ellipse params
    const padding = Math.min(w, h) * 0.07;
    const cx = w / 2;
    const cy = h / 2;
    const a = (w / 2) - padding;
    const b = (h / 2) - padding;

    const n = Math.max(3, parseInt(controls.n.value, 10));
    let skip = parseInt(controls.skip.value, 10);

    // limit skip to < n
    if (skip >= n) skip = skip % n || 1;

    const pts = buildPoints(n, cx, cy, a, b, rotation);

    // optionally draw ellipse outline
    if (controls.outline.checked) {
      ctx.save();
      ctx.beginPath();
      // draw parametric ellipse with many segments for smoothness
      const segs = Math.max(60, Math.min(360, Math.floor(n)));
      for (let i = 0; i <= segs; i++) {
        const t = (i / segs) * Math.PI * 2 + rotation;
        const [x, y] = ellipsePoint(cx, cy, a, b, t);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#999';
      ctx.stroke();
      ctx.restore();
    }

    // draw stitches
    ctx.save();
    ctx.lineWidth = parseFloat(controls.width.value);
    ctx.strokeStyle = controls.color.value;
    ctx.globalAlpha = 0.9;

    // Best practice: draw with path batching for speed
    ctx.beginPath();
    for (let i = 0; i < n; i++) {
      const j = (i + skip + skipOffset) % n;
      const [x1, y1] = pts[i];
      const [x2, y2] = pts[j];
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.stroke();
    ctx.restore();

    // optionally draw points
    if (controls.points.checked) {
      ctx.save();
      ctx.fillStyle = '#222';
      const r = Math.max(1, Math.min(3, Math.round(3 * (200 / n))));
      for (let i = 0; i < n; i++) {
        const [x, y] = pts[i];
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  // UI wiring
  function updateLabels() {
    controls.nLabel.textContent = controls.n.value;
    controls.skipLabel.textContent = controls.skip.value;
    controls.wLabel.textContent = controls.width.value;
  }

  ['n','skip','color','width','outline','points'].forEach(id => {
    controls[id].addEventListener('input', () => {
      updateLabels();
      draw();
    });
  });

  // Fit button
  controls.fit.addEventListener('click', () => {
    fitCanvas();
    draw();
  });

  // Download PNG
  controls.download.addEventListener('click', () => {
    // create a temporary canvas at full pixel size for high-res download
    const ratio = window.devicePixelRatio || 1;
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width;
    tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');
    // draw current canvas content onto tmp (canvas already scaled)
    tctx.drawImage(canvas, 0, 0);
    const url = tmp.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ellipse-stitching.png';
    a.click();
  });

  // Animation: rotate ellipse + slowly change skip offset for motion
  let lastTs = 0;
  function animateFrame(ts) {
    if (!controls.animate.checked) {
      lastTs = 0;
      return;
    }
    if (!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    // rotate slowly
    rotation += dt * 0.30; // radians per second
    // slowly change skip offset to create evolving pattern
    skipOffset = (skipOffset + dt * 10) | 0; // integer offset increments
    draw();
    requestAnimationFrame(animateFrame);
  }

  // start/stop animation when checkbox toggled
  controls.animate.addEventListener('change', () => {
    if (controls.animate.checked) {
      lastTs = 0;
      requestAnimationFrame(animateFrame);
    } else {
      lastTs = 0;
      draw();
    }
  });

  // initialize labels and draw
  updateLabels();
  fitCanvas();
  draw();

  // draw continuously if animation is on (safety)
  setInterval(() => {
    if (controls.animate.checked) {
      // ensure animation continues if requestAnimationFrame stopped
      requestAnimationFrame(animateFrame);
    }
  }, 1000);

})();
</script>

</body>
</html>
