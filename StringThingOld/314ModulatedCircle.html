<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modulated Circle Explorer</title>
<style>
  :root{--bg:#f6f7fb;--panel:#fff;--muted:#666;--accent:#ff4fa3}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);-webkit-font-smoothing:antialiased}
  .app{max-width:1100px;margin:20px auto;display:flex;gap:18px;padding:12px}
  .controls{width:320px;background:var(--panel);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
  .control{display:flex;align-items:center;gap:8px;margin-bottom:10px}
  label{width:140px;color:var(--muted);font-size:13px}
  input[type=range]{flex:1}
  .val{width:56px;text-align:right;font-variant-numeric:tabular-nums}
  select,input[type=color]{flex:1;padding:6px;border-radius:6px;border:1px solid #eee}
  button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.ghost{background:#f3f4f6;color:#111}
  .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:10px;align-items:center}
  canvas{background:#fff;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.06);max-width:100%}
  .row{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  .footer{font-size:12px;color:var(--muted);margin-top:6px}
  .h{font-weight:600;margin:8px 0 12px 0}
</style>
</head>
<body>
  <div class="app">
    <div class="controls" role="region" aria-label="Controls">
      <div class="h">Modulated Circle Explorer</div>

      <div class="control"><label for="baseR">Base Radius</label><input id="baseR" type="range" min="10" max="600" value="180"/><div class="val" id="baseR-val">180</div></div>

      <div class="control"><label for="amp">Amplitude</label><input id="amp" type="range" min="0" max="400" value="60"/><div class="val" id="amp-val">60</div></div>

      <div class="control"><label for="freq">Frequency (n)</label><input id="freq" type="range" min="0" max="24" value="7"/><div class="val" id="freq-val">7</div></div>

      <div class="control"><label for="phase">Phase (deg)</label><input id="phase" type="range" min="0" max="360" value="0"/><div class="val" id="phase-val">0°</div></div>

      <div class="control"><label for="wave">Waveform</label>
        <select id="wave">
          <option value="sine">Sine</option>
          <option value="cos">Cosine</option>
          <option value="triangle">Triangle</option>
          <option value="square">Square</option>
          <option value="saw">Sawtooth</option>
          <option value="sum">Harmonic sum (1..n)</option>
          <option value="noise">Noise (Perlin-like)</option>
        </select>
      </div>

      <div class="control"><label for="harmAmp">Harmonic Amp</label><input id="harmAmp" type="range" min="0" max="1" step="0.01" value="0.6"/><div class="val" id="harmAmp-val">0.60</div></div>

      <div class="control"><label for="samples">Samples</label><input id="samples" type="range" min="32" max="2048" value="720"/><div class="val" id="samples-val">720</div></div>

      <div class="control"><label for="color">Stroke</label><input id="color" type="color" value="#ff4fa3"/></div>

      <div class="control"><label for="lineW">Line Width</label><input id="lineW" type="range" min="0.2" max="6" step="0.1" value="1"/><div class="val" id="lineW-val">1.0</div></div>

      <div class="control"><label for="animate">Animate</label><div class="row"><input id="animate" type="checkbox"/><div class="small">rotate / phase</div></div></div>

      <div class="control"><label for="speed">Animate Speed</label><input id="speed" type="range" min="0.01" max="3" step="0.01" value="0.4"/><div class="val" id="speed-val">0.40</div></div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="reset" class="ghost">Reset</button>
        <button id="export">Export PNG</button>
      </div>

      <div class="footer">Try waveforms, change n, amplitude, and sample resolution. Use harmonic sum for rich shapes. Noise gives organic outlines.</div>
    </div>

    <div class="canvas-wrap">
      <canvas id="canvas" width="760" height="760"></canvas>
      <div class="row small" style="width:100%;justify-content:space-between;padding:0 6px 6px 6px">
        <div id="info">r(θ) = R + A·w(nθ+φ)</div>
        <div id="coords" class="small"></div>
      </div>
    </div>
  </div>

<script>
/* Modulated Circle Explorer
   - r(θ) = R + A * w( n*θ + φ )
   - Supports multiple waveforms, harmonic sum, and noise
   - Interactive controls update drawing immediately
*/

// Helpers: clamp, lerp, toRad
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const toRad = deg => deg * Math.PI/180;

// Waveforms: all accept a phase input x (radians) and return value in [-1,1]
function sineWave(x){ return Math.sin(x); }
function cosWave(x){ return Math.cos(x); }
function triWave(x){
  // triangle wave ranged [-1,1]
  const s = (x/Math.PI) % 2;
  const u = (s+2)%2;
  return 1 - 2*Math.abs(u-1);
}
function squareWave(x){ return Math.sign(Math.sin(x)) || 1; }
function sawWave(x){
  // saw from -1 to 1
  return 2*( (x/(2*Math.PI)) - Math.floor(0.5 + x/(2*Math.PI)) );
}
// simple value noise seeded by angle (smooth-ish via sin combos)
function noise1(x){
  // cheap smooth pseudo-noise: sum of sines with incommensurate frequencies
  return (Math.sin(x*1.0*1.0) + Math.sin(x*1.7*1.3) * 0.6 + Math.sin(x*2.9*0.7)*0.35)/ (1 + 0.6 + 0.35);
}

// harmonic sum: normalized sum of k=1..n sin(k*x)/k (scaled)
function harmonicSum(x, n, ampScale){
  let s=0;
  for(let k=1;k<=n;k++){
    s += Math.sin(k * x) * (1/(k)); // diminishing amplitude
  }
  // normalize approximate amplitude by harmonic series factor (H_n ≈ ln n + gamma)
  const H = Math.log(Math.max(2,n)) + 0.5772156649;
  return (s / H) * ampScale;
}

// DOM elements
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const baseR = document.getElementById('baseR');
const amp = document.getElementById('amp');
const freq = document.getElementById('freq');
const phase = document.getElementById('phase');
const wave = document.getElementById('wave');
const samples = document.getElementById('samples');
const color = document.getElementById('color');
const lineW = document.getElementById('lineW');
const animate = document.getElementById('animate');
const speed = document.getElementById('speed');
const exportBtn = document.getElementById('export');
const resetBtn = document.getElementById('reset');
const info = document.getElementById('info');
const coords = document.getElementById('coords');
const harmAmp = document.getElementById('harmAmp');

// labels
const ids = ['baseR','amp','freq','phase','samples','lineW','speed','harmAmp'];
ids.forEach(id=>{
  const el = document.getElementById(id);
  const lab = document.getElementById(id+'-val');
  if(!lab) return;
  el.addEventListener('input',()=>{ 
    if(id==='phase') lab.textContent = el.value + '°';
    else lab.textContent = (id==='lineW' || id==='harmAmp' || id==='speed') ? Number(el.value).toFixed(2) : el.value;
    drawOnce();
  });
});

// responsive canvas (keep CSS size fixed, scale resolution by DPR)
function resizeCanvas(){
  const dpr = Math.max(1, window.devicePixelRatio||1);
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',() => { resizeCanvas(); drawOnce(); });

// mapping waveform select
function waveformFunc(name){
  if(name==='sine') return sineWave;
  if(name==='cos') return cosWave;
  if(name==='triangle') return triWave;
  if(name==='square') return squareWave;
  if(name==='saw') return sawWave;
  if(name==='noise') return noise1;
  if(name==='sum') return null; // handled specially
  return sineWave;
}

// visual parameters
let animTheta = 0;
let raf = null;

// main drawing routine
function draw(t){
  // t in ms from requestAnimationFrame
  resizeCanvas();
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

  const cx = canvas.clientWidth/2;
  const cy = canvas.clientHeight/2;

  // read parameters
  const R = Number(baseR.value);
  const A = Number(amp.value);
  const n = Number(freq.value);
  const ph = toRad(Number(phase.value));
  const samp = Number(samples.value);
  const stroke = color.value;
  const lw = Number(lineW.value);
  const wname = wave.value;
  const harmonicAmpScale = Number(harmAmp.value);

  // animation: if enabled, advance phase or rotate
  if(animate.checked && typeof t === 'number'){
    animTheta += (Number(speed.value) * 0.001); // small step per frame
  }

  // Angle offset applied to waveform (drives rotation-like motion)
  const animPhase = animTheta;
  // Build sample points
  const points = new Array(samp+1);
  // choose waveform function
  const wf = waveformFunc(wname);

  for(let i=0;i<=samp;i++){
    const theta = (i / samp) * Math.PI * 2;
    let wval;
    const x = n * theta + ph + animPhase;
    if(wname === 'sum'){
      wval = harmonicSum(x, Math.max(1, n), harmonicAmpScale);
    } else if(wname === 'noise'){
      // noise1 returns roughly -1..1; scale with harmonicAmp to control
      wval = noise1(x) * harmonicAmpScale;
    } else {
      wval = wf(x) || 0;
    }
    // final radius
    const r = R + A * wval;
    const px = cx + r * Math.cos(theta);
    const py = cy + r * Math.sin(theta);
    points[i] = { x: px, y: py, r, theta };
  }

  // draw outline
  ctx.beginPath();
  ctx.lineWidth = lw;
  ctx.strokeStyle = stroke;
  ctx.lineJoin = 'round';
  ctx.moveTo(points[0].x, points[0].y);
  for(let i=1;i<=samp;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.closePath();
  ctx.stroke();

  // optional small center cross
  ctx.fillStyle = '#222';
  ctx.globalAlpha = 0.06;
  ctx.fillRect(cx-1, cy-1, 2, 2);
  ctx.globalAlpha = 1;

  // show info text
  info.textContent = `r(θ) = R + A · w(nθ + φ)   (wave=${wname}, samples=${samp})`;

  // show mouse coords if set
  if(lastMouse && lastMouseInCanvas){
    coords.textContent = `x=${lastMouse.x.toFixed(1)}, y=${lastMouse.y.toFixed(1)}`;
  } else coords.textContent = '';

  // draw sample points small if samples small (optional)
  if(samp <= 256){
    ctx.fillStyle = stroke;
    for(let p of points){
      ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.8, Math.min(3, lw)), 0, Math.PI*2); ctx.fill();
    }
  }

  // schedule next frame if animating
  if(animate.checked) raf = requestAnimationFrame(draw);
}

// single redraw (cancel rAF while redrawing if animation off)
function drawOnce(){
  if(raf){ cancelAnimationFrame(raf); raf = null; }
  draw();
}

// export PNG
exportBtn.addEventListener('click', ()=>{
  // temporarily render at higher res for export
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const tmp = document.createElement('canvas');
  const scale = 2;
  tmp.width = w * scale; tmp.height = h * scale;
  const g = tmp.getContext('2d');
  g.fillStyle = '#fff'; g.fillRect(0,0,tmp.width,tmp.height);

  // draw same shape scaled
  const cx = tmp.width/2, cy = tmp.height/2;
  const R = Number(baseR.value) * scale;
  const A = Number(amp.value) * scale;
  const n = Number(freq.value);
  const ph = toRad(Number(phase.value));
  const samp = Number(samples.value);
  const stroke = color.value;
  const lw = Number(lineW.value) * scale;
  const wname = wave.value;
  const harmonicAmpScale = Number(harmAmp.value);
  const wf = waveformFunc(wname);

  const animPhase = animTheta;
  const points = [];
  for(let i=0;i<=samp;i++){
    const theta = (i / samp) * Math.PI * 2;
    const x = n * theta + ph + animPhase;
    let wv;
    if(wname==='sum') wv = harmonicSum(x, Math.max(1,n), harmonicAmpScale);
    else if(wname==='noise') wv = noise1(x) * harmonicAmpScale;
    else wv = wf(x) || 0;
    const r = R + A * wv;
    points.push({x: cx + r*Math.cos(theta), y: cy + r*Math.sin(theta)});
  }
  g.beginPath();
  g.lineWidth = lw; g.strokeStyle = stroke; g.lineJoin = 'round';
  g.moveTo(points[0].x, points[0].y);
  for(let i=1;i<points.length;i++) g.lineTo(points[i].x, points[i].y);
  g.closePath(); g.stroke();

  const url = tmp.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = 'modulated-circle.png';
  a.click();
});

// reset to defaults
resetBtn.addEventListener('click', ()=>{
  baseR.value = 180; amp.value = 60; freq.value = 7; phase.value = 0;
  wave.value = 'sine'; samples.value = 720; color.value = '#ff4fa3';
  lineW.value = 1; animate.checked = false; speed.value = 0.4; harmAmp.value = 0.6;
  ids.forEach(id => {
    const el = document.getElementById(id);
    const lab = document.getElementById(id+'-val');
    if(el && lab){
      if(id==='phase') lab.textContent = el.value + '°';
      else if(id==='lineW' || id==='harmAmp' || id==='speed') lab.textContent = Number(el.value).toFixed(2);
      else lab.textContent = el.value;
    }
  });
  drawOnce();
});

// mouse position display
let lastMouse = null, lastMouseInCanvas = false;
canvas.addEventListener('mousemove', (ev)=>{
  const r = canvas.getBoundingClientRect();
  lastMouse = { x: ev.clientX - r.left, y: ev.clientY - r.top };
  lastMouseInCanvas = true;
});
canvas.addEventListener('mouseleave', ()=>{ lastMouseInCanvas = false; coords.textContent = ''; });

// initial UI hookup and draw
// initialize labels
ids.forEach(id=>{
  const el = document.getElementById(id);
  const lab = document.getElementById(id+'-val');
  if(el && lab){
    if(id==='phase') lab.textContent = el.value + '°';
    else if(id==='lineW' || id==='harmAmp' || id==='speed') lab.textContent = Number(el.value).toFixed(2);
    else lab.textContent = el.value;
  }
});
resizeCanvas(); drawOnce();

// handle changing wave select -> immediate redraw
wave.addEventListener('input', drawOnce);
harmAmp.addEventListener('input', drawOnce);
animate.addEventListener('change', ()=>{
  if(animate.checked) { if(!raf) raf = requestAnimationFrame(draw); }
  else { if(raf){ cancelAnimationFrame(raf); raf = null; } drawOnce(); }
});
speed.addEventListener('input', ()=>{ document.getElementById('speed-val').textContent = Number(speed.value).toFixed(2); });
</script>
</body>
</html>
