<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spiralize Voronoi</title>
  <style>
    body { margin:0; background:white; }
    canvas { display:block; margin:auto; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
</head>
<body>
<p>
What the Mathematica code does
<pre>
    spiralize[p, d, r, f, s, t]
        Takes a polygon p (list of vertices).
        Around the mean/centroid m, repeatedly:
            Rotate by r + k*s degrees
            Scale by f

        d = depth (how many nested copies).
        t = stroke thickness.
</pre>
<p>Finally it draws all those nested spiraled polygons.

<p>The second part:
<pre>
    Makes a Voronoi diagram from random points.
    Takes the polygonal regions, applies spiralize to each, and overlays them
</pre>
<p>This:
<pre>
    Generates 50 random points.
    
    Builds a Voronoi diagram over the canvas.

    Each Voronoi cell is passed to spiralize, which makes
    nested spiraling polygons (rotated + shrunk).
</pre>

<canvas id="spiral" width="800" height="800"></canvas>
<script>
const canvas = document.getElementById("spiral");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

// Parameters similar to Mathematica
function spiralize(polygon, {
  depth=40,
  r=5,
  f=0.85,
  s=1,
  t=0.5
}={}) {
  // Compute centroid
  let cx=0, cy=0;
  polygon.forEach(pt => { cx += pt[0]; cy += pt[1]; });
  cx /= polygon.length;
  cy /= polygon.length;
  ctx.lineWidth = t;
  ctx.strokeStyle = "black";
  ctx.fillStyle = "white";

  let rr = r;
  let poly = polygon.map(pt => [...pt]);
  ctx.beginPath();
  drawPolygon(poly);

  for (let i=0; i<depth; i++) {
    // rotate around centroid
    let angle = (rr + s) * Math.PI/180;
    rr += s;
    poly = poly.map(([x,y]) => {
      let dx = x - cx, dy = y - cy;
      return [
        cx + dx*Math.cos(angle) - dy*Math.sin(angle),
        cy + dx*Math.sin(angle) + dy*Math.cos(angle)
      ];
    });

    // scale about centroid
    poly = poly.map(([x,y]) => [
      cx + f*(x-cx),
      cy + f*(y-cy)
    ]);

    drawPolygon(poly);
  }
  ctx.stroke();
}

function drawPolygon(poly) {
  ctx.moveTo(poly[0][0], poly[0][1]);
  for (let i=1;i<poly.length;i++) {
    ctx.lineTo(poly[i][0], poly[i][1]);
  }
  ctx.closePath();
}

// === Build random Voronoi polygons ===
let pts = Array.from({length:50}, () => [
  Math.random()*W,
  Math.random()*H
]);

const delaunay = d3.Delaunay.from(pts);
const vor = delaunay.voronoi([0,0,W,H]);

// Spiralize each polygon
for (let i=0;i<pts.length;i++) {
  let cell = vor.cellPolygon(i);
  if (cell) spiralize(cell, {depth:40, r:5, f:0.85, s:1, t:0.3});
}
</script>
</body>
</html>
