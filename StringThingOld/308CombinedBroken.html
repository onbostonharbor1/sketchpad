<!--
Perfect addition for Phase 4 experimentation, Barry. Hereâ€™s a unified HTML file with four curve modes:

1. Rose Curve
2. Lissajous Curve
3. Custom Cartesian: user-defined `x(t)` and `y(t)`
4. Custom Radial: user-defined `r(Î¸)`


Each mode reveals its own controls, and the draw logic is modular and inspectableâ€”ideal for symbolic overlays later.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Curve Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f0f0f0;
    }
    canvas {
      border: 1px solid #333;
      background: white;
    }
    .controls {
      margin-top: 10px;
    }
    .controls label {
      display: block;
      margin: 5px 0;
    }
    .hidden {
      display: none;
    }
    input[type="text"] {
      width: 100%;
    }
  </style>
</head>
<body>
  <h2>ðŸŒ€ Curve Visualizer</h2>
  <label>
    Curve Type:
    <select id="mode">
      <option value="rose">Rose Curve</option>
      <option value="lissajous">Lissajous Curve</option>
      <option value="cartesian">Custom Cartesian</option>
      <option value="polar">Custom Radial</option>
    </select>
  </label>

  <canvas id="curveCanvas" width="500" height="500"></canvas>

  <!-- Rose Controls -->
  <div class="controls" id="roseControls">
    <label>Lobes (k): <input type="range" id="lobes" min="1" max="20" value="5" /><span id="lobesVal">5</span></label>
    <label>Amplitude (a): <input type="range" id="amplitude" min="50" max="200" value="100" /><span id="amplitudeVal">100</span></label>
    <label>Resolution: <input type="range" id="roseResolution" min="100" max="2000" value="1000" /><span id="roseResolutionVal">1000</span></label>
  </div>

  <!-- Lissajous Controls -->
  <div class="controls hidden" id="lissajousControls">
    <label>Frequency X (a): <input type="range" id="freqX" min="1" max="20" value="3" /><span id="freqXVal">3</span></label>
    <label>Frequency Y (b): <input type="range" id="freqY" min="1" max="20" value="2" /><span id="freqYVal">2</span></label>
    <label>Phase Shift (Î´): <input type="range" id="phase" min="0" max="628" value="314" /><span id="phaseVal">Ï€</span></label>
    <label>Resolution: <input type="range" id="lissResolution" min="100" max="2000" value="1000" /><span id="lissResolutionVal">1000</span></label>
  </div>

  <!-- Cartesian Controls -->
  <div class="controls hidden" id="cartesianControls">
    <label>x(t): <input type="text" id="xExpr" value="200 * Math.sin(t)" /></label>
    <label>y(t): <input type="text" id="yExpr" value="200 * Math.cos(t)" /></label>
    <label>Resolution: <input type="range" id="cartesianResolution" min="100" max="2000" value="1000" /><span id="cartesianResolutionVal">1000</span></label>
  </div>

  <!-- Polar Controls -->
  <div class="controls hidden" id="polarControls">
    <label>r(Î¸): <input type="text" id="rExpr" value="150 + 50 * Math.sin(3 * theta)" /></label>
    <label>Resolution: <input type="range" id="polarResolution" min="100" max="2000" value="1000" /><span id="polarResolutionVal">1000</span></label>
  </div>

  <script>
    const canvas = document.getElementById('curveCanvas');
    const ctx = canvas.getContext('2d');
    const modeSelect = document.getElementById('mode');

    const panels = {
      rose: document.getElementById('roseControls'),
      lissajous: document.getElementById('lissajousControls'),
      cartesian: document.getElementById('cartesianControls'),
      polar: document.getElementById('polarControls')
    };

    function drawRose(k, a, resolution) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(250, 250); ctx.beginPath();
      for (let i = 0; i <= resolution; i++) {
        const theta = (i / resolution) * 2 * Math.PI;
        const r = a * Math.cos(k * theta);
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = '#0077cc'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
    }

    function drawLissajous(a, b, delta, resolution) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(250, 250); ctx.beginPath();
      for (let i = 0; i <= resolution; i++) {
        const t = (i / resolution) * 2 * Math.PI;
        const x = 200 * Math.sin(a * t + delta);
        const y = 200 * Math.sin(b * t);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = '#cc0077'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
    }

    function drawCartesian(xExpr, yExpr, resolution) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(250, 250); ctx.beginPath();
      for (let i = 0; i <= resolution; i++) {
        const t = (i / resolution) * 2 * Math.PI;
        let x = eval(xExpr);
        let y = eval(yExpr);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = '#00aa55'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
    }

    function drawPolar(rExpr, resolution) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save(); ctx.translate(250, 250); ctx.beginPath();
      for (let i = 0; i <= resolution; i++) {
        const theta = (i / resolution) * 2 * Math.PI;
        let r = eval(rExpr);
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = '#aa5500'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
    }

    function update() {
      const mode = modeSelect.value;
      Object.keys(panels).forEach(key => panels[key].classList.toggle('hidden', key !== mode));

      if (mode === 'rose') {
        const k = +document.getElementById('lobes').value;
        const a = +document.getElementById('amplitude').value;
        const res = +document.getElementById('roseResolution').value;
        document.getElementById('lobesVal').textContent = k;
        document.getElementById('amplitudeVal').textContent = a;
        document.getElementById('roseResolutionVal').textContent = res;
        drawRose(k, a, res);
      } else if (mode === 'lissajous') {
        const a = +document.getElementById('freqX').value;
        const b = +document.getElementById('freqY').value;
        const delta = +document.getElementById('phase').value / 100;
        const res = +document.getElementById('lissResolution').value;
        document.getElementById('freqXVal').textContent = a;
        document.getElementById('freqYVal').textContent = b;
        document.getElementById('phaseVal').textContent = (delta === Math.PI) ? 'Ï€' : delta.toFixed(2);
        document.getElementById('lissResolutionVal').textContent = res;
        drawLissajous(a, b, delta, res);
      } else if (mode === 'cartesian') {
        const xExpr = document.getElementById('xExpr').value;
        const yExpr = document.getElementById('yExpr').value;
        const res = +document.get
 
 â€”â€”â€”â€”â€”â€”â€”â€”

Absolutely, Barryâ€”hereâ€™s the continuation of the `update()` function from where it left off, completing the logic for the Cartesian and Polar modes:

      } else if (mode === 'cartesian') {
        const xExpr = document.getElementById('xExpr').value;
        const yExpr = document.getElementById('yExpr').value;
        const res = +document.getElementById('cartesianResolution').value;
        document.getElementById('cartesianResolutionVal').textContent = res;
        drawCartesian(xExpr, yExpr, res);
      } else if (mode === 'polar') {
        const rExpr = document.getElementById('rExpr').value;
        const res = +document.getElementById('polarResolution').value;
        document.getElementById('polarResolutionVal').textContent = res;
        drawPolar(rExpr, res);
      }
    }

    // Bind all inputs to update
    modeSelect.addEventListener('change', update);
    document.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', update);
    });

    update(); // initial draw
  </script>
</body>
</html>
<!--

---

ðŸ§  Architectural Notes

â€¢ Each mode is fully modular and inspectable.
â€¢ `eval()` is used for expression parsingâ€”great for experimentation, but you might later replace it with a symbolic parser for safety and provenance.
â€¢ You can now test overlays, symbolic scaffolds, and registry-driven draw routines across all four curve types.
-->
