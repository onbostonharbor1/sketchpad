<html
  <head><title>Self contained pursuit</title></head>
  <body>
<p>
Here’s a self-contained function that accepts:

<p>    canvasId – which canvas to draw on
<br>    n – number of points
<br>    steps – iterations
<br>    dt – step size
<br>    radius – initial circle size
<br>    rule – pursuit rule ("next", "kth", "speeds", "centroid", or "custom")
<br>    options – extra settings depending on the rule (like k for k-th pursuit, custom mapping, speed array, etc.)
 <canvas id="pursuit" width="600" height="600"></canvas>

<script>

function drawPursuitCurves({
  canvasId="pursuit",
  n=6,
  steps=3000,
  dt=0.05,
  radius=200,
  speed=1.0,
  rule="next",  // "next", "kth", "speeds", "centroid", "custom"
  options={}
}) {

  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // Initialize points on a circle
  let pts = [];
  for (let i = 0; i < n; i++) {
    let theta = 2 * Math.PI * i / n;
    pts.push({
      x: W/2 + radius * Math.cos(theta),
      y: H/2 + radius * Math.sin(theta)
    });
  }

  ctx.clearRect(0,0,W,H);
  ctx.strokeStyle = "rgba(0,0,255,0.8)";
  ctx.lineWidth = 0.5;
  ctx.beginPath();

    for (let s = 0; s < steps; s++) {
	// Draw polygon
	ctx.moveTo(pts[0].x, pts[0].y);
	for (let i = 1; i < n; i++)
	    ctx.lineTo(pts[i].x, pts[i].y);
	ctx.lineTo(pts[0].x, pts[0].y);

	// Update positions
	let newPts = [];
	for (let i = 0; i < n; i++) {
	    let target;
	    if (rule === "next") {
		target = pts[(i+1) % n];
	    } 
	    else if (rule === "kth") {
		const k = options.k || 2; // default k=2
		target = pts[(i+k) % n];
	    }
	    else if (rule === "speeds") {
		const speeds = options.speeds || Array(n).fill(speed);
		const j = (i+1) % n;
		let dx = pts[j].x - pts[i].x;
		let dy = pts[j].y - pts[i].y;
		newPts.push({
		    x: pts[i].x + speeds[i] * dx * dt,
		    y: pts[i].y + speeds[i] * dy * dt
		});
		continue;
	    }
	    else if (rule === "centroid") {
		let cx = pts.reduce((s,p) => s+p.x,0)/n;
		let cy = pts.reduce((s,p) => s+p.y,0)/n;
		target = {x:cx, y:cy};
	    }
	    else if (rule === "custom" && typeof options.mapFn === "function") {
		let j = options.mapFn(i,n); // must return index
		target = pts[j];
	    } else {
		target = pts[(i+1)%n]; // fallback
	    }
	    
	    let dx = target.x - pts[i].x;
	    let dy = target.y - pts[i].y;
	    newPts.push({
		x: pts[i].x + speed * dx * dt,
		y: pts[i].y + speed * dy * dt
	    });
	}
	pts = newPts;
    }
    ctx.stroke();
}


// Examples of usage:

// standard pursuit
drawPursuitCurves({canvasId:"pursuit",
		   n:4,
		   rule:"next"
		  }); 

// drawPursuitCurves({canvasId:"pursuit", n:7, rule:"kth",
//                    options:{k:2}});

//drawPursuitCurves({canvasId:"pursuit", n:8, rule:"speeds",
//                   options:{speeds:[0.5,1,1.5,0.7,1.2,0.8,1,0.9]}});

// drawPursuitCurves({canvasId:"pursuit", n:5, rule:"centroid"});

//drawPursuitCurves({canvasId:"pursuit", n:6, rule:"custom",
//		   options:{mapFn:(i,n)=> (i+2)%n}});

</script>
  </body>
  </html>
