<html>
<body>
<canvas id="boat" width="900" height="600"></canvas>
<script>
/**
 * Draw Hamid Naderi Yeganeh's "Boat" as a curve-stitch on a 2D canvas.
 * Can be called from anywhere; pass either a canvas or a 2D context.
 *
 * Equations (n = 1..N):
 *   P1(n) = ( sin(12π n/N)^3 , cos(10π n/N)^3 )
 *   P2(n) = ( sin( 8π n/N)^3 , cos( 6π n/N)^3 )
 * (These generate the well-known 2000-segment "Boat".)
 *
 * @param {HTMLCanvasElement|CanvasRenderingContext2D} target
 * @param {Object} [opts]
 *   - N: number of segments (default 2000)
 *   - margin: padding around drawing (px)
 *   - bg: background fill style (or null for transparent)
 *   - stroke: stroke style
 *   - lineWidth: stroke width in CSS px
 *   - alpha: global alpha for strokes (0..1)
 *   - gamma: non-linear scale for y to better fill tall canvases (1 = none)
 *   - fit: "contain" | "cover" scaling behavior (default "contain")
 */
function drawBoat(target, opts = {}) {
  const cfg = {
    N: 2000,
    margin: 24,
    bg: "#ffffff",
    stroke: "#111",
    lineWidth: 0.75,
    alpha: 1,
    gamma: 1,      // try 0.9..1.2 to taste
    fit: "contain",
    ...opts
  };

  // Get 2D context
  const ctx = target.getContext
    ? target.getContext("2d", { alpha: cfg.bg == null })
    : target;
  const { canvas } = ctx;

  // Clear & background
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (cfg.bg) {
    ctx.fillStyle = cfg.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Build normalized endpoints in [-1,1]x[-1,1]
  const N = cfg.N|0;
  const p1 = new Float32Array(2*N);
  const p2 = new Float32Array(2*N);

  const pi = Math.PI;
  const sin = Math.sin, cos = Math.cos;
  const pow3 = x => x*x*x;

  for (let n = 1; n <= N; n++) {
    const t = n / N;
    // P1(n)
    const x1 = pow3(sin(12*pi*t));
    let y1 = pow3(cos(10*pi*t));
    // optional vertical gamma for aesthetics
    if (cfg.gamma !== 1) y1 = Math.sign(y1) * Math.pow(Math.abs(y1), cfg.gamma);

    // P2(n)
    const x2 = pow3(sin(8*pi*t));
    let y2 = pow3(cos(6*pi*t));
    if (cfg.gamma !== 1) y2 = Math.sign(y2) * Math.pow(Math.abs(y2), cfg.gamma);

    const i = (n-1)*2;
    p1[i] = x1;   p1[i+1] = y1;
    p2[i] = x2;   p2[i+1] = y2;
  }

  // Determine scale to canvas
  // Compute bounding box (it’s already ~[-1,1], but gamma can stretch)
  let minX =  1e9, minY =  1e9, maxX = -1e9, maxY = -1e9;
  for (let i = 0; i < 2*N; i += 2) {
    const xA = p1[i],   yA = p1[i+1];
    const xB = p2[i],   yB = p2[i+1];
    if (xA < minX) minX = xA; if (xA > maxX) maxX = xA;
    if (yA < minY) minY = yA; if (yA > maxY) maxY = yA;
    if (xB < minX) minX = xB; if (xB > maxX) maxX = xB;
    if (yB < minY) minY = yB; if (yB > maxY) maxY = yB;
  }
  const wData = maxX - minX, hData = maxY - minY;
  const wAvail = canvas.width  - 2*cfg.margin;
  const hAvail = canvas.height - 2*cfg.margin;
  const sx = wAvail / wData;
  const sy = hAvail / hData;
  const s  = (cfg.fit === "cover") ? Math.max(sx, sy) : Math.min(sx, sy);

  // Centering translation
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const tx = canvas.width/2  - s*cx;
  const ty = canvas.height/2 - s*cy;

  // Draw
  ctx.globalAlpha = cfg.alpha;
  ctx.lineWidth = cfg.lineWidth;
  ctx.strokeStyle = cfg.stroke;
  ctx.lineCap = "round";

  // Batch many segments for speed using Path2D (fallback to manual if needed)
  const path = (typeof Path2D !== "undefined") ? new Path2D() : null;
  if (path) {
    for (let i = 0; i < 2*N; i += 2) {
      const ax = tx + s*p1[i],   ay = ty + s*p1[i+1];
      const bx = tx + s*p2[i],   by = ty + s*p2[i+1];
      path.moveTo(ax, ay);
      path.lineTo(bx, by);
    }
    ctx.stroke(path);
  } else {
    ctx.beginPath();
    for (let i = 0; i < 2*N; i += 2) {
      const ax = tx + s*p1[i],   ay = ty + s*p1[i+1];
      const bx = tx + s*p2[i],   by = ty + s*p2[i+1];
      ctx.moveTo(ax, ay);
      ctx.lineTo(bx, by);
    }
    ctx.stroke();
  }
  ctx.restore();
}

// Example usage: call from anywhere (e.g., window.onload or your app code)
drawBoat(document.getElementById("boat"), {
  N: 2000,           // try 4000 or 8000 for extra density
  lineWidth: 0.7,
  stroke: "#0b1a2b",
  bg: "#fff",
  gamma: 1.0
});
</script>
</body>
</html>
